前情回顾
1. httpserver （http协议 + tcp套接字）HTTP协议：请求，响应                                                                                                                         -
* 接收浏览器发来的请求 （HTTP请求）
* 查看请求内容
* 组织http响应子串
* 将内容发送给浏览器显示

2. IO 形态
    阻塞IO ： 默认IO 遇到条件阻塞或者传输阻塞会暂停程序运行。效率低
    非阻塞IO ：设置属性或者设置超时检测
                效率提升   
    IO多路复用 
    	目的 ： 在程序中有多个 IO事件的时候，同时监控，哪个能够执行就执行哪个，提高效率
    	方法 ： select  poll
    	      设置要监控的io。阻塞等待IO事件发生。哪个发生就处理哪个IO
******************************************************
1.epoll（支持水平触发（直到完成为止），边缘触发（可以等待下次触发时，一起完成））
  使用方法： 代码与poll基本一致
  * 将生产的对象 改为  p = epoll() 
  * 将关注事件类别名称改为epoll的关注事件类别

  区别 :  
  epoll（新） 效率要高于select  和 poll
  epoll 的事件触发方式更多--> EPOLLET(边缘触发)

2.本地套接字（作用 ：用于本地不同程序间进行数据传输(通信)）
  cookie
  linux下文件类型
  b(块设备文件(驱动文件) block)       c（字符设备文件  character）    d（目录 document）   
  -（普通文件）  l（链接文件  link）    s（套接字文件 socket）       p（管道文件 pipeline）

  1.本地套接字传输流程
    1. 创建套接字对象
      sockfd = socket(AF_UNIX,SOCK_STREAM)
    2. 绑定 {套接字} 文件，如果文件不存在则{自动创建}
      *选定文件位置和名称
      *sockfd.bind(path)
    3. 监听 listen()
    4. 消息收发  recv  send

    s = socket()  s.connect(path)  s.recv s.send 

  cookie
  os.path.exists(file)
  功能 ： 判断一个文件是否存在
  参数 ： 文件
  返回值: 存在 True   不存在 False

  os.remove()
  os.unlink()
  功能 ：删除一个文件
  参数 ：要删除的文件

网络基础总结：
理论 ： 1. OSI七层模型  tcp/ip模型
        2. TCP 和  UDP的区别和特征
      	3. 三次握手和四次挥手的过程和每一次作用
      	4. 什么是IO多路复用，IO的基本形态 select poll epoll
      	5. 套接字的种类，套接字类型的区别 tcp udp 本地套接字

程序实践 ： 1. TCP套接字传输的基本模型 --文件传输
            2. UDP套接字传输基本模型   --广播
      	    3. IO多路复用select poll的使用  --
      	    4. HTTP协议基本原理的实现    --请求协议 响应协议

3.多任务编程
  1.意义： 充分利用计算机资源，同时运行多个任务，提高程序整体的运行{效率}
  2.定义：通过应用程序利用计算机的 {多个核心} 达到同时执行多个任务的目的。
         以此达到提升程序运行效率的目的
  3.实施方案 ： 多进程编程   多线程编程（每一个线程都能承担一个任务）

4.并行和并发：
  并行：{多个计算机核心} 在同时处理多个任务，这时多个任务之间是并行关系
  并发：同时运行多个任务，内核在多个任务间{不断切换}，达到好像都在处理运行的效果。但实际一个时间点内核只能处理其中一个任务。（操作系统决定并发or并行，但可人为干预）
5.进程和程序
  1.进程（Process）：程序在计算机中的一次运行过程（本质是运行过程）
  2.程序（Procedure）：是一个可执行文件，是静态的占有磁盘，不占计算机的运行资源
  3.进程： 进程是一个动态的过程的描述，占有计算机资源，有一定的生命周期
    * 同一个程序不同的运行过程是不同的进程。因为分配的 {资源和生命周期} 都不相同
  4.进程的创建流程
    1. 用户空间通过{运行程序或者调用接口}发起创建进程
    2. 操作系统接收{用户请求}，分配计算机资源创建进程
    3. 操作系统分配计算机资源，确定进程状态，开辟进程空间等工作
    4. 操作系统将创建搞得进程提供给应用程序使用

6.进程相关概念：
  1.cpu时间片：
    如果一个进程占有计算机核心，我们称为该进程占有{计算机CPU时间片}
    多个进程任务会轮流占有cpu时间片形成并发效果。
    *多个任务之间是争夺CPU的关系
    *谁占有CPU最终是操作系统决定

  2.进程信息 （process）  process block
    PCB（进程控制块）：进程创建后会自动在内存生产一个空间存放进程信息。
    *进程控制块是操作系统查找识别进程的标志
    进程信息：进程的ID、进程占有内存的位置、创建时间、创建用户。。。
    查看系统该进程信息：ps（process）  -aux
    PID(process ID) : 在操作系统中每个进程都有唯一的ID号，用来区别与其他进程。ID号由操作系统自动分配，是一个大于0的整数

  3.父子进程：在系统中除了初始化进程每个进程都有{一个父进程}，可能有{0个或多个子}进程。
              由此形成进程间的父子关系。parent process  child process
              查看进程树： pstree
              查看父子进程PID ：  ps  -ajx
              便于进程管理，父进程发起创建子进程请求



  进程的状态
    三态：
      * 就绪态 ： 进程具备执行条件，等待系统分配处理器资源进入运行态
      * 运行态 ： 进程占有cpu处于运行状态
      * 等待态 ： 进程暂时不具备运行条件，需要阻塞等待，瞒住条件后可再次运行
    五态：（三态基础上增加新建和终止）
      * 新建 ： 创建一个新的进程，获取系统资源的过程
      * 终止 ： 进程执行结束，释放资源的过程
      
      ps -aux  ---> STAT表示进程状态
      S  等待态 睡眠   可中断等待态
      D  等待态 阻塞   不可中断等待态
      T  等待态 暂停   暂停执行
      R  运行态      （就绪态）
      Z  僵尸

   <  有较高优先级的进程
   N  较低优先级的进程
   l  有进程连接
   s  会话组
   + 前台进程（在终端运行，直接进行交互的进程。 没有+的为后台进程） 

  进程的优先级：
    作用：决定了进程的执行权限和占用资源的优先程度
    查看进程优先级：
      top 动态查看进程优先级 ，   <  > 进行翻页  q退出
      优先级的取值范围 ：-20  ---  19    -20最高

    使用指定的优先级运行程序：
    nice ： 以指定的优先级运行一个程序
    格式：nice -i(整数)  文件路径      i  (-20,19)
    nice   -9   ./while.py  以9的优先级运行
    sudo nice   --9   ./while.py  以-9优先级运行(0以下都需要加 sudo)
    cookie  
    首行添加
    #！/usr/bin/python3

    修改程序权限添加可执行权限
    chmod  775  while.py

    可以直接指明路径执行
    ./while.py

    进程特征
    * 进程之间运行{相互独立}互不影响
    * 每个进程空间独立，各自占有一定的虚拟内存
    * 进程是操作系统分配{资源}的最小单元

要求：
1.什么是进程，进程和程序的区别
2.了解进程的特征和基本概念
3.理解并发并行的区别
4.清楚进程的每种状态，以及每种状态转换关系



7.多进程编程
  import os  
  os.fork 创建进程
  pid = os.fork()
  功能 ： 创建进程
  返回值：失败:返回一个负数
          成功:在原有进程中返回新进程的PID号
  	           在新进程中返回0
  
  * 父进程中fork返回值即为新创建子进程的PID号
  * 父子进程不一定谁先执行，执行上互不干扰抢占时间片 
  * 子进程会复制父进程全部代码段，包括fork之前产生的内存空间
  * 子进程从fork的下一句开始执行，与父进程互不干扰
  * 父子进程的执行顺序是不一定的，父子进程公用一个终端显示
  * 父子进程通常会根据fork返回值得差异选择执行不同的代码。所以if结构几乎是fork的固定搭配
  * 父子进程空间独立，操作的都是本空间的内容，互不影响
  * 子进程虽然复制父进程内容，但是也有自己的特有属性特征。比如： PID号 PCB 内存区间等



获取进程PID
os.getpid()
功能：获取当前进程的PID号
返回值：返回进程的PID号

os.getppid()
功能：获取当前进程父进程的PID号
返回值 ： 返回父进程的PID号

进程退出
os._exit(status)
功能：退出一个进程
参数： 进程的退出状态整数

sys.exit([status])
功能 ： 退出一个进程
参数 ： 默认为0
        如果传入一个整数则同 _exit()
	      传入一个字符串。则在对出时打印该字符串
* sys.exit() 可以通过try...except...捕获 SystemExit异常阻止退出

  孤儿进程：父进程先与子进程退出，此时进程就称为孤儿进程。
  *孤儿进程会被操作系统指定的进程收养，系统进程就成为孤儿进程的新的父进程
  僵尸进程：子进程先于父进程退出，但是父进程没有处理子进程的退出状态，此时子进程就会成为僵尸进程
          *僵尸进程会滞留部分PCB信息在内存中，大量的僵尸进程会消耗系统的内存资源，所以要尽量避免僵尸进程产生


作业 ： 进程fork理解
        熟悉进程的理论

        写一个聊天室
        功能：类似QQ群聊
        1.进入聊天室需要输入姓名，姓名不能重复
        2.有人进入聊天室 会向其他人发送通知
           xxx 进入聊天室
        3.一人发消息，其他人会收到通知
           xxx 退出聊天室
        客户端  ---服务端 ----客户端

        服务端  客户端
        *使用什么技术
        *知识点回顾复习

        多进程
        IO多路复用


