前情回顾

1. epoll 实现IO多路复用
2. 本地套接字：   AF_UNIX  绑定一个套接字文件  实现两个进程自之间的消息通信
    作用 ： 本地进程间的通信
3. 多任务编程
  并行  并发
  进程  线程
4. 多进程编程
    进程特征 : 最小的资源分配单元
               独立的空间
	             互不影响的运行状态
    进程状态 ： 就绪态   运行态   等待态  
    时间片 PCB PID  父子进程 进程特征 优先级（可指定优先级）   
5.  创建进程
    import os
    os.fork()
    os.getpid()   os.getppid()
    os._exit()    sys.exit(){可以被捕获异常}

    孤儿进程 
    僵尸进程
****************************************************
1.如何避免僵尸进程产生:
  *处理子进程退出状态：
  pid,status = os.wait()
  功能：在父进程中{阻塞等待}处理子进程退出
  返回值：pid 退出的子进程的PID号
          status 获取子进程退出状态 * 256
  获取原来退出状态
  os.WEXITSTATUS(status)

  pid,status = os.waitpid(pid,option)
  功能 ： 在父进程中阻塞等待处理子进程的退出
  参数 ： pid    -1  表示等待任意子进程退出
                 >0  表示等待对应PID号的子进程退出
          option   0 表示阻塞等待 
                 WNOHANG （wnohang） 表示非阻塞
  返回值：pid  退出的那个子进程的PID号
          status  子进程的退出状态
  *waitpid(-1,0)  ===> wait()

  * 父进程先退出----->创建二级子进程
    1.父进程创建子进程等待子进程退出
    2.子进程创建下一级子进程，然后立即退出
    3.二级子进程成为孤儿，处理具体工作


简单的群聊聊天室
功能 ： 类似于qq群聊
1. 进入聊天室需要输入姓名 姓名不能重复
2.有人进入聊天室此时会向其他人发起通知
  xxx 进入了聊天室
3. 如果一个人发消息，则其他人都能收到
   xxx 说 ： xxxxxxx
4. 如果某个人退出聊天室其他人也会收到通知
   xxx 退出了聊天室
5. 服务端可以喊话 ：此时群里所有人都能收到服务端消息
   管理员 说：xxx


功能模块：转发
需要技术：套接字通信，UDP套接字
用户存储：字典或列表
消息收发的而随意性：多进程

代码设计：
1.封装:将每个功能封装为函数
2.接口测试（没实现一步就测试一步）

代码编写流程：
搭建网络连接，--》创建多进程--》每个进程功能编写--》项目功能模块实现

服务端   客户端
在客户端和服务端每个功能{封装为一个函数}

技术方案：
转发 ： 一个客户端发送给服务器，服务器发送给其他人
套接字使用 ：udp 完成操作
用户存储： 字典 或者 列表  （可变类型，能够遍历提取）
           地址  用户名
发送和接受消息的控制：发送和接收使用{多进程分离}互不影响

注意事项：
1.注重封装
2.分段测试

功能细节梳理

进入聊天室 
   客户端:输入姓名 
          将信息发送给服务器  L name
	        接受到服务端返回结果，根据回复判断是否登录成功 
   服务端:接受消息   判断请求类型 判断用户名是否存在 
   --》如果存在，回复不能登录
   --》如果不存在， 回复让其登录，和插入到数据结构  并发送通知给其他用户

	     判断是否可以登录（姓名是否已经存在）
	     返回给客户端是否登录（如果可以服务端会将姓名插入到存储结构）
	     给所有人发送消息

聊天
      客户端 ： 发起聊天  C name msg
                接受服务器回复

      服务器 ： 接受消息 
                判断消息类型
		组织消息结构转发给其他客户端
	
退出聊天室
      客户端 ： 发送消息退出  Q  name
                接受回复
		退出程序
      服务端 ： 接受消息
                判断请求类型
		从用户结构删除对应用户
		告知所有人，xxx退出

2.multiprocessing 模块创建进程
  1. 需要将要做的事情封装成函数
  2. 使用multiprocessing提供的类Process创建进程对象
  3. 通过进程对象属性设置和Process初始化函数对进程进行进程的设置，绑定要执行的函数
  4. 启动进程，会自动执行绑定的函数
  5. 完成进程的回收

1.创建进程对象
  Process（target,name,args,kwargs）
  功能： 创建进程对象
  参数： target ： 要绑定的函数
         name ： 给进程起的名称 （默认Process-1）
         args： 元组 用来给target函数(位置传参)
         kwargs : 字典  用来给target函数键值传参
name:给进程起名字
      默认为Process-1 Process-2.....
      p.name 可以获取进程名称
2.p.start()
  功能：启动进程 
  *target函数会自动执行，此时进程真正被创建
  p.join([timeout])
  功能：阻塞，等待回收子进程
  参数：超时时间

* 使用multiprocessing创建进程子进程同样复制父进程的全部内存空间，之后有自己独立的空间，执行上互不干扰
* 子进程也是有自己特有的PID等资源
* 如果不使用join回收字进程，则子进程退出后会成为僵尸进程
* 使用multiprocessing创建子进程，一般父进程功能就是创建子进程回收子进程，所有事件交给子进程完成

作业 ： 1.梳理 聊天室代码 思路
        2.对进程概念和创建过程巩固
      	3.加深对http协议的理解
        4.巩固multiprocessing创建进程的方法
        5.创建父子进程，分别将一个文件的上半部分和下半部分，复制到一个新的文件中。创建进程方法自选
         以字节区分

