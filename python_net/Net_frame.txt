网络编程
1、网络目的：数据的传输
   网络数据传输是一个复杂的过程    (网络干线（高速公路）)
2、ISO ：国际标准化组织
3、OSI 七层模型(作用：网络通信流程标准化)  
  上层到底层：
    应用层：提供用户服务，具体功能由特定程序规定 (例子：微信、邮箱)
    表示层：数据的压缩(rar,zip)优化 、加密
    会话层：建立应用级连接，选择传输服务(虚拟连接)
    传输层：提供不同的传输服务(视频，音频，文件)，流量控制
    网络层：路由选择，网络互连
    链路层：提供链路交换，具体消息以帧发送，链路连接
    物理层：物理硬件，接口设定，网卡路由交换机等，线路

    osi七层模型优点 ：1.将工作流程标准化
                      2.降低了模块间的耦合度，使每一部分可以单独开发，单独工作。
      将功能分开，降低了网络传输中的耦合性，每一部分完成自己的功能。
      可以在开发和实施的过程中各司其职。
    cookie（编程思想）
    高内聚 ：单个模块功能尽量单一
    低耦合 ：模块之间尽量减少关联和影响

4、四层模型:
  应用层：应用层、表示层、会话层
  传输层
  网络层
  物理链路层：链路层、物理层
5、五层（tcp/ip模型）
  应用层 ： 应用层   表示层  会话层
  传输层 ： 传输层
  网络层 ： 网络层
  链路层 ： 链路层
  物理层 ： 物理层

6、数据传输流程：
  1.发送端由应用层到物理层逐层添加信息头（首部），最终在物理层发送。
  2.中间进过节点（交换机，路由器等）转发，发送到接收端
  3.在接收端根据发送端的每个信息头进行解析，最终消息到应用层展示给用户。


7、协议（网络协议）：在网络通信中，各方必须遵守的规定。
   包括：建立什么样的连接，消息结构，标识代表什么等。

    应用层 ： TFTP   HTTP  DNS   SMTP
    传输层 ： TCP（数据流）   UDP（数据报）
    网络层 ： IP 
    物理层 ： IEEE

8、网络基本概念
  网络主机：在网络中标识一台计算机 HOST
  本地使用："localhost" 表示本台计算机
            '127.0.0.1'
  网络使用：如果想在网络上进行测试
            '0.0.0.0'   ''  ifconfig（查询IP地址） '172.60.50.93'（本机的IP）
    cookie 
    查看 IP网络信息
    linux    ifconfig 
    win      ipconfig

  获取计算机名称
  In [2]: socket.gethostname()
  Out[2]: 'tedu'
  获取主机IP
  In [5]: socket.gethostbyname('localhost')
  Out[5]: '127.0.0.1'

9、IP地址：在网络上确定一台主机网络位置的地址
  IPv4 ： 点分十进制    e.g. 192.168.1.2   每一部分取值范围：0-255
          32位二进制表示 
  IPv6 ： 128位二进制  2**128-1
  ping IP地址： 测试和某台网络主机是否联通
  特殊IP
  127.0.0.1     本地测试IP
  0.0.0.0       本地网卡通用IP
  192.168.1.0   表示当前网段IP
  192.168.1.1   表示网关IP
  192.168.1.255 广播地址

10、获取服务主机信息
  In [7]: socket.gethostbyaddr("www.baidu.com")
  Out[7]: ('127.0.0.1', [],   ['119.75.213.61'])
            主机        别名   IP地址
  将ip十进制转化为二进制  套接字（socket)
  In [12]: socket.inet_aton("192.168.1.2")
  Out[12]: b'\xc0\xa8\x01\x02'
  将ip二进制转化为十进制
  In [11]: socket.inet_ntoa(b"\xc0\xa8\x01\x02")
  Out[11]: '192.168.1.2'

11、域名:网络服务器 {IP地址} 的名称  例子：www.baidu.com
    优点：1.方便记忆
          2.名称表达一定的含义
    url:在网络上定位某个资源位置的字串

    网络端口号 ：端口号是网络地址的一部分，在一个系统中，每个网络应用都会有一个唯一的
                端口号，取来区别其他应用，接受发往这个端口的消息。
    在一个操作系统中不同的网络应用监听不同的端口号
    数字范围：1--65535
              1--255 一些中众所周知的通用端口
              256--1023 系统应用端口
              1025--65535 自用端口
              建议使用 > 10000

    测试一个软件端口号
    In [13]: socket.getservbyname('mysql')
                                   软件名
    Out[13]: 3306
             socket.getservbyname
12、网络字节序：数据在网络中的传输格式

13、传输层服务（tcp/udp)
  1、面向连接的传输服务 ---》 基于tcp协议的数据传输
    传输特征：提供可靠的数据传输，可靠性指数据传输过程中无丢失，无失序，无差错，无重复。
    实现手段：数据的传输断开前都需要进行传输和断开的确认
      1.三次握手：tcp传输在数据传输前建立连接的过程
        1. 客户端向服务器发起连接请求
        2. 服务器收到请求后，回复确认消息，表示允许连接
        3. 客户端收到服务器回复，进行最终标志发送确认连接

      2.四次挥手：tcp传输在连接断开前进行断开确认的过程
        1.主动方发送报文，告知被动方要断开连接
        2.被动方收到请求后立即返回报文告知已经准备断开
        3.被动方贮备就绪后再次发送报文告知准备完毕可以断开
        4.主动方发送报文，最终确认断开
    适用情况：文件的上传下载，网络情况良好，需要必须保证可靠性的情况
    比如 ：信息聊天，文件上传下载，邮件，网页获取
  2、面向无连接的传输服务 ---》 udp协议
    传输特征 ：
    * 不保证传输的可靠性
    * 无需建立三次握手和四次挥手的连接断开过程
    * 消息的收发比较自由，不受其他约束
    适用情况 ：网络情况较差，对可靠性要求不高，收发消息的两端不适合建立固定连接
    比如 ：网络视频，群聊，广播发送

14、要求 ：
  1. osi七层模型介绍一下，tcp/ip模型
  2. tcp服务和udp服务有什么区别
  3. 三次握手和四次挥手时什么意思，过程是怎么样的
15、socket套接字编程
  1.目的：根据socket（套接字）模块提供的接口函数，进行组合使用完成
          基于tcp或udp的网络编程。
  2.套接字：完成上述目标的编程手法，编程方案
  3套接字的分类：    stream
    流式套接字（SOCK_STREAM）: 传输层基于tcp(对接）的协议进行通信
    数据报套接字（SOCK_DGRAM）：传输层基于udp(无对接)的协议进行通信
    底层套接字（SOCK_RAM）:访问底层协议的套接字编程
    本地套接字
  
  *面向连接的传输--tcp协议--可靠的--流式套接字SOCK_STRESAM
  *面向无连接传输--udp协议--不可靠--数据报接字SOCK_DGRAM

-************************-
1、TCP套接字编程
    1、服务端
    import  socket
    1. 创建套接字   点操作
      sockfd = socket.socket(socket_family = AF_INET,
                            socket_type = SOCK_STREAM,
                            proto = 0)
    功能：创建一个套接字
    参数：socket_family：选择地址族类型  AF_INET 表示IPv4   AF_INET6  IPv6
          socket_type：  选择套接字类型  SOCK_STREAM 流式   tcp 
                                          SOCK_DGRAM  数据报 udp
          proto:选择子协议类型    通常为0 （表示选择子协议）
    返回值：返回一个套接字对象

    2. 绑定服务端地址IP端口
      sockfd.bind(（Ip,port）)
      功能：绑定IP地址和端口
      参数：元组（ip,port)二元元组，第一项为ip 第二项为端口号
                        e.g. ("192.168.1.2",8888)
      localhost 可以被本机用 127.0.0.1
      127.0.0.1  同上
      192.168.205.127（本机IP） 可以被别人用192.168.205.127访问
      0.0.0.0 可以被别人用192.168.205.127访问
              也可以被自己用127.0.0.1访问
    3. 将套接字设置为可监听（只有TCP才有）
      sockfd.listen(n)
      功能：将套接字设置为监听套接字，并设置监听队列
      参数：n表示监听队列的大小   n为大于0 的正整数
      *一个监听套接字可以连接多个客户端套接字
    4. 等待、处理客户端连接请求
      connfd,addr = sockfd.accept()
      功能： 阻塞等待处理客户端连接
      返回值 ：connfd  一个新的套接字，用于和[指定客户]端通信
                addr    连接的客户端的地址
      * 阻塞函数：程序运行到阻塞函数位置，如果某种{预期条件}没有达成则暂停继续运行，
                 直到条件达成后再继续运行(eg.：input())
    5.消息收发
      data = connfd.recv(buffersize)
      功能 ： 接收对应客户端消息
      参数 ： 每次最多接收的多少字节  bytes
      返回值 ：返回接收到的内容   decode()
      *如果没有消息则会阻塞
      n = connfd.send(data)
      功能 ： 发送消息
      参数 ： 要发送的内容  必须是bytes格式  encode()
      返回值 ：返回实际发送的字节数
      
    6.关闭套接字
      sockfd.close()
      功能 ：关闭套接字，tcp连接断开
      * telnet  ip   port   表示连接tcp服务端

  2、tcp客户端
    1.创建套接字
    socket()
    *必须相同类型的套接字才能通信

    2. 建立连接
    sockfd.connect(servr_addr)
    功能 ： 发起连接请求
    参数 ： 元组，服务器端的地址

    3.消息收发
    send  recv
    * 消息收发要和服务端配合，避免两边都出现recv阻塞

    4.关闭套接字
    close（）



1.套接字传输注意事项
  1. 监听套接字存在客户端即可发起连接，但是最终连接的处理需要accept进行处理
  2. 如果连接的另外一段退出，则recv会立即返回空子串不再阻塞。
  3. 当连接的另一端退出时，再试图send发送就会产生BrokenPipeError

  recv()  特征
  * 如果连接的另一端断开连接，则recv立即返回空子串
  * recv是从接受缓冲区取出内容，当缓冲区为空则阻塞
  * recv如果一次接受不完缓冲区内容，下次会继续接收
  send() 特征
  * 如果发送的另外一段不存在则会产生Pipe Broken
  * recv是向发送缓冲区发送内容，当缓冲区为满阻塞

2.网络的收发缓冲区
  在内存中开辟的区域，用作发送和接受的缓冲
  作用：
  * 协调数据收发（接受和处理）速度
  * 减少和磁盘的交互

3.tcp粘包：
  产生原因： 
  * tcp传输以字节流的方式发送消息，消息之间没有边界
    发送和接收并不能保证每次发送都及时的被接收
  * 发送比接受的速度快：
    1影响：如果每次发送内容表达一个独立的含义此时可能需要处理粘包防止产生歧义
    2处理方法：
        1.每次发送的消息添加结尾标志（人为增加消息边界）
        2.发送数据结构体
        3.协调收发速度，每次发送后都预留接收时间
4.基于UDP编程：
  1.基于UDP的服务端编程（数据报套接字）
    1. 创建套接字
      sockfd = socket(AF_INET,SOCK_DGRAM)
    2. 绑定地址
      sockfd.bind(（ip,端口）)   对比tcp(s.listen(n)  s.accept())
    3. 消息收发
      1.data,addr = sockfd.recvfrom(buffersize)
        功能： 接受UDP消息
        参数： 每次最多接受消息的大小  字节
        返回值：data 接收到的内容
                addr 消息发送方的地址
        * recvfrom每次接收一个数据报文，如果数据报大小大于buffersize，则丢弃没有收到的内容(对比：tcp 则会继续读取)
      2.sockfd.sendto(data,addr)
        功能： UDP消息发送
        参数： data  要发送的内容   bytes
               addr  目标地址（元组）
        返回：发送字节数    eg.: L = sockfd.sendto(data,addr)
    4. 关闭套接字
      sockfd.close()
  2.基于udp客户端编程
    1.创建套接字 
      socket(AF_INET,SOCK_DGRAM)
    2.消息收发
      recvfrom/sendto(data,(ip,端口))
    3.关闭套接字
      close()

  cookie ： 
    1.import  sys 
      sys.argv 属性
      作用：获取从命令行参数，得到一个列表  eg.:python3 xxxx.py
      命令本身是：sys.argv[0] 
      后面的参数从argv[1]开始，默认以空格分隔，使用引号引起来的内容算做一个整体
      命令行参数都以字符串放入列表
    2.
      在程序的第一行加
      #!/usr/bin/env python3
      添加程序的执行权限
      chmod 755 file.py
      修改后即可通过 ./file.py 运行程序


5.tcp流式套接字和udp数据报套接字区别:
1. 流式套接字采用{字节流}方式进行传输，而数据报套接字以{数据报}形式传输数据
2. tcp套接字会产生{粘包}，udp有{消息边界(buttersize)}不会形成粘包
3. tcp编程可以保证消息的{完整性}，udp则不能保证
4. tcp需要进行listen  accept(产生新的套接字) 操作，udp不需要
5. tcp收发消息使用新的套接字，recv  send  sendall，udp使用 recvfrom，sendto
    补充函数：
    sendall(data)
      功能 ： tcp套接字发送消息
      参数 ： 要发送的内容，bytes格式（同send）
      返回值：如果发送成功返回None  失败产生异常

  要求 ： 能够说出tcp，udp协议的区别和编程实现上的差异


6.soccket模块和套接字属性
  （s为套接字）s = socket(family,type)
  1.套接字属性
    s.family : 获取套接字{地址族} 类型
    s.type :  获取套接字{类型}
  2.套接字属性方法 
    1.s.getsockname()
      功能:获取套接字绑定的{地址}
    2.s.fileno()
      功能:获取套接字的文件描述符
      文件描述符:每一个{}操作系统都会分配一个不同的正整数作为编号与之匹配，该整数即为此IO的文件描述符
      *文件描述符是操作系统识别IO的唯一标志
      sys.stdin   0
      sys.stdout  1
      sys.stderr  2  
    3.s.getpeername()
      功能 ：获取客户端连接{套接字的地址}
    4.s.setsockopt(level,optname,value)
      功能:设置套接字选项，丰富或者修改套接字属性功能
      参数: level   设置选项的类别  SOL_SOCKET
            optname   子类选项
            value    要设置的值
      *如果要设置套接字选项，最好在创建套接字之后立即设置
    5.s.getsockopt(level,optname)
      功能 ： 获取套接字选项值
      参数 ： level   要获取选项的类型   SOL_SOCKET
              option   子类选项
      返回值：获取的值

7.udp套接字应用 ---》 广播（broadcast）
  广播：一点发送，多点接收
  广播地址：一个网段内有一个指定的广播地址，是该网段的最大值  176.136.17.255
  cookie：format{}
  In [3]: s = "{} is a {}".format('Tom','boy')

  In [4]: s
  Out[4]: 'Tom is a boy'

  In [5]: s = "{1} is a {0}".format('Tom','boy')

  In [6]: s
  Out[6]: 'boy is a Tom'

8.tcp套接字应用之http传输
  1.http协议：超文本传输协议，是一个应用层协议
    用途：网页数据的传输
          数据传输方法
          网站中浏览器获取网页的过程
          编写基于http协议的数据传输
    特点 ： 
      1. 应用层协议，传输层使用tcp服务(应，表，会，传，网，链，物)
      2. 简单，灵活，多种语言都有http相关操作接口（可以使用多种编程语言操作）
      3. 无状态的协议，即不记录用户传输的信息
      4. http1.1  支持持久连接
       一端通过http请求的格式发送具体请求内容，另一端接收http请求，按照协议格式解析。获取真实请求后按照http 
  2.http请求（request）
    请求格式：
      1.请求行：具体的请求类别和请求内容
        格式： GET            /            HTTP/1.1
             请求类别     请求内容         协议版本
        请求类别：表示请求的种类
          GET     获取网络资源
          POST    提交一定的附加数据，得到返回结果
          HEAD    获取响应头
          PUT     更新服务器资源
          DELETE  删除服务器资源
          CONNECT  
          TRACE   用于测试
          OPTIONS 获取服务器性能信息
      2.请求头：对请求的{内容具体描述}
        Accept:text/html
        * 每一个键值对占一行，描述了一个特定信息
      空行
      3.请求体：请求参数(get)或者提交具体内容(post)
                get参数或者post提交的内容
  3.http响应 （response）
    响应格式:
    1.响应行:反馈具体的响应情况
      格式：  HTTP/1.1     200        OK
              协议版本   响应码     附加信息
      响应码 ：响应的具体情况  
              1xx  提示信息，表示请求已经接受
              2xx  响应成功
              3xx  响应需要重定向
              4xx  客户端错误
              5xx  服务端错误
      常见响应码
      200    成功
      404    请求内容不存在
      401    没有访问权限
      500    服务器发生未知错误
      503    服务器暂时无法执行    
    2.响应头：对响应内容的具体描述
      Content-Encoding: gzip
      Content-Type: text/html
      空行
    3.响应体：返回给请求端的{具体内容}

      要求：1.什么是http协议、作用
            2.请求的格式和每一部分的功能
            3.响应的格式和每一部分功能
            4.常见的请求类型和响应码代表什么
             get/post   1xx/2xx/3xx/4xx/5xx
            5.掌握http协议 请求和响应的格式以及每一部分做什么
          http请求：请求行、头、体
          http响应：响应行、头、体


1.tcp应用之 httpserver
    * 接收http请求
    * 查看http请求
    * 返回一个网页给客户端

2.IO（input  output）
  1.在内存中存在{数据交换}的操作可以认为是IO操作(输入输出）
  2.e.g.：
    内存和磁盘进行数据交换：文件的读写（read/write)  数据库更新(updata)
    内存和终端数据交换：input   print  
                        sys.stdin sys.stdout  sys.stderr  stand
    内存和网络数据的交换： 网络连接  recv  send  recvfrom
    IO密集型程序:在程序执行中有大量的IO操作，而较少的cpu运算操作。消耗cpu较少，IO运行时间长
    cpu（计算）密集型程序：程序中存在大量的cpu运算，IO操作相对较少，消耗cpu大，运行速度快。
  3.IO分类：
    阻塞IO   非阻塞IO    IO多路复用  {事件驱动IO  异步IO}
    1.阻塞IO：io的默认形态，是效率较低的一种IO情形。
      程序运行中遇到IO条件没有达成或者传输过程较慢的情况会出现阻塞状态
      * 阻塞IO是 IO最简单的逻辑情形，也是默认状态
      * 阻塞IO是效率很低的IO形态
      阻塞情况 ：
      * 因为某种IO条件没有达到形成阻塞
       e.g.   accept  recv   recvfrom   input
      * 处理IO事件的时候耗时较长形成阻塞
       e.g.  文件读写过程，网络数据发送过程    
    2.非阻塞IO ：在程序运行中遇到IO的情形不让其产生阻塞，通过修改IO事件的属性，使其变为非阻塞状态。
                （让一些条件阻塞函数不再阻塞）
      * 通常会和循环一起使用，进行条件的循环监控
      1.s.setblocking(False)
        功能 ：将套接字设置为非阻塞
        参数 ：默认为阻塞状态 设置为False则为非阻塞
      超时检测
      将原本阻塞的函数，设置一个{阻塞的最长时间}。如果时间内条件达成则
      2.s.settimeout(sec)
        功能 ： 设置套接字的超时时间
        参数 ： 时间（秒）
    3.IO多路复用
      1.定义：通过一个监测，可以同时监控多个IO事件的行为。当哪个IO事件准备就绪就执行那个IO事件，以此形成可用同时
              操作多个IO的并发行为，避免一个IO堵塞，造成所有IO都无法执行。
      2.IO准备就绪:是一种IO必然就要发生的临界状态
        1.将IO设置为关注IO
        2.将关注IO提交给内核监测
        3.处理内核给我们反馈的准备就绪的IO 
      3.具体方案：
        select ---》 Windows Linux Unix
        poll ---》 Linux Unix
        epoll --》linux unix
        import  select
        rs, ws, xs = select(rlist, wlist, xlist[, timeout])
      功能 ： 监控IO事件，阻塞阻塞等待IO事件发生
      参数 ：rlist   列表  存放我们监控需要等待处理的IO事件（读IO事件）  accept
             wlist   列表  存放我们想主动操作的IO事件（写IO事件）        send
             xlist   列表  存放出错，希望去处理的IO
             timeout  超时时间
      返回值:  rs   列表  rlist中准备就绪的IO
               ws   列表  wlist中准备就绪的IO
               xs   列表  xlist中准备就绪的IO
      注意：1.wlist中如果有IO事件，则select立即返回为ws
            2.在处理IO过程中不要处理一个客户端长期占有服务端，使服务端无法运行到select的情况
            3.IO多路复用占用计算机资源少，IO效率高
      * 在处理IO时不要形成死循环，让一个客户端单独占有服务端
      * IO多路复兴形成一种可以同时处理多个IO的效果，效率较高


3.位运算
  按照二进制位进行运算操作
  & 按位与    | 按位或     ^ 按位异或 
  << 左移       >>  右移 
  11    1011  32 16 8 4 2 1
  14    1110

  &     1010   一0则0  10
  |     1111   一1则1  
  ^     0101   相同0不同1

  11 << 2  ===> 44   右侧补0
  14 >> 2  ===> 3    挤掉右侧的数字
 
  使用：1. 在做底层硬件时操作寄存器
        2. 做标志位的过滤
        3.检查某位  与其相同位为1 计算按位与 &
        4.增加功能  与其相同位为1 计算按位或 |

4.poll方法实现IO多路复用 select.poll/ p.register/unregister  p.poll
  1. 创建poll对象
    p = select.poll()
  2.添加注册关注的IO事件
    p.register(s,POLLIN | POLLERR)
      事件类别
      POLLIN   POLLOUT   POLLERR   POLLHUP   POLLNVAL         POLLPRI  （整数）  
      rlist    wlist     xlist     断开      无效数据        紧急处理
    p.unregister(s)   从关注IO事件中移除
  3.阻塞等待IO发生 监控IO 
    events = p.poll()
    功能:监控关注的IO事件
    返回值：events 是一个列表，列表中给每个元素都是一个元组，代表一个发生的IO事件
      [(fileno,               evnet),(),()....]
      就绪IO的文件描述符    具体就绪事件
      *需要通过文件描述符(fileno)找到对应的IO对象
      每个就绪IO对应列表中一个元组：（描述符，就绪事件）
      IO地图 ： {s.fileno():s}
  4.处理具体的IO




1.epoll（支持水平触发（直到完成为止），边缘触发（可以等待下次触发时，一起完成））
  使用方法： 代码与poll基本一致
  * 将生产的对象 改为  p = epoll() 
  * 将关注事件类别名称改为epoll的关注事件类别

  区别 :  
  epoll（新） 效率要高于select  和 poll
  epoll 的事件触发方式更多--> EPOLLET(边缘触发)

2.本地套接字（作用 ：用于本地不同程序间进行数据传输(通信)）
  cookie
  linux下文件类型
  b(块设备文件(驱动文件) block)       c（字符设备文件  character）    d（目录 document）   
  -（普通文件）  l（链接文件  link）    s（套接字文件 socket）       p（管道文件 pipeline）

  1.本地套接字传输流程
    1. 创建套接字对象
      sockfd = socket(AF_UNIX,SOCK_STREAM)
    2. 绑定 {套接字} 文件，如果文件不存在则{自动创建}
      *选定文件位置和名称
      *sockfd.bind(path)
    3. 监听 listen()
    4. 消息收发  recv  send
    s = socket()  s.connect(path)  s.recv s.send 

  cookie
  os.path.exists(file)
  功能 ： 判断一个文件是否存在
  参数 ： 文件
  返回值: 存在 True   不存在 False

  os.remove()
  os.unlink()
  功能 ：删除一个文件
  参数 ：要删除的文件

网络基础总结：
理论 ： 1. OSI七层模型  tcp/ip模型
        2. TCP 和  UDP的区别和特征
        3. 三次握手和四次挥手的过程和每一次作用
        4. 什么是IO多路复用，IO的基本形态 select poll epoll
        5. 套接字的种类，套接字类型的区别 tcp udp 本地套接字

程序实践 ： 1. TCP套接字传输的基本模型 --文件传输
            2. UDP套接字传输基本模型   --广播
            3. IO多路复用select poll的使用  --
            4. HTTP协议基本原理的实现    --请求协议 响应协议

3.多任务编程
  1.意义： 充分利用计算机资源，同时运行多个任务，提高程序整体的运行{效率}
  2.定义：通过应用程序利用计算机的 {多个核心} 达到同时执行多个任务的目的。
         以此达到提升程序运行效率的目的
  3.实施方案 ： 多进程编程   多线程编程（每一个线程都能承担一个任务）

4.并行和并发：
  并行：{多个计算机核心} 在同时处理多个任务，这时多个任务之间是并行关系
  并发：同时运行多个任务，内核在多个任务间{不断切换}，达到好像都在处理运行的效果。但实际一个时间点内核只能处理其中一个任务。（操作系统决定并发or并行，但可人为干预）
5.进程和程序
  1.进程（Process）：程序在计算机中的一次运行过程（本质是运行过程）
  2.程序（Procedure）：是一个可执行文件，是静态的占有磁盘，不占计算机的运行资源
  3.进程： 进程是一个动态的过程的描述，占有计算机资源，有一定的生命周期
    * 同一个程序不同的运行过程是不同的进程。因为分配的 {资源和生命周期} 都不相同
  4.进程的创建流程
    1. 用户空间通过{运行程序或者调用接口}发起创建进程
    2. 操作系统接收{用户请求}，分配计算机资源创建进程
    3. 操作系统分配计算机资源，确定进程状态，开辟进程空间等工作
    4. 操作系统将创建搞得进程提供给应用程序使用

6.进程相关概念：
  1.cpu时间片：
    如果一个进程占有计算机核心，我们称为该进程占有{计算机CPU时间片}
    多个进程任务会轮流占有cpu时间片形成并发效果。
    *多个任务之间是争夺CPU的关系
    *谁占有CPU最终是操作系统决定

  2.进程信息 （process）  process block
    PCB（进程控制块）：进程创建后会自动在内存生产一个空间存放进程信息。
    *进程控制块是操作系统查找识别进程的标志
    进程信息：进程的ID、进程占有内存的位置、创建时间、创建用户。。。
    查看系统该进程信息：ps（process）  -aux
    PID(process ID) : 在操作系统中每个进程都有唯一的ID号，用来区别与其他进程。ID号由操作系统自动分配，是一个大于0的整数

  3.父子进程：在系统中除了初始化进程每个进程都有{一个父进程}，可能有{0个或多个子}进程。
              由此形成进程间的父子关系。parent process  child process
              查看进程树： pstree
              查看父子进程PID ：  ps  -ajx
              便于进程管理，父进程发起创建子进程请求



  进程的状态
    三态：
      * 就绪态 ： 进程具备执行条件，等待系统分配处理器资源进入运行态
      * 运行态 ： 进程占有cpu处于运行状态
      * 等待态 ： 进程暂时不具备运行条件，需要阻塞等待，瞒住条件后可再次运行
    五态：（三态基础上增加新建和终止）
      * 新建 ： 创建一个新的进程，获取系统资源的过程
      * 终止 ： 进程执行结束，释放资源的过程
      
      ps -aux  ---> STAT表示进程状态
      S  等待态 睡眠   可中断等待态
      D  等待态 阻塞   不可中断等待态
      T  等待态 暂停   暂停执行
      R  运行态      （就绪态）
      Z  僵尸

   <  有较高优先级的进程
   N  较低优先级的进程
   l  有进程连接
   s  会话组
   + 前台进程（在终端运行，直接进行交互的进程。 没有+的为后台进程） 

  进程的优先级：
    作用：决定了进程的执行权限和占用资源的优先程度
    查看进程优先级：
      top 动态查看进程优先级 ，   <  > 进行翻页  q退出
      优先级的取值范围 ：-20  ---  19    -20最高

    使用指定的优先级运行程序：
    nice ： 以指定的优先级运行一个程序
    格式：nice -i(整数)  文件路径      i  (-20,19)
    nice   -9   ./while.py  以9的优先级运行
    sudo nice   --9   ./while.py  以-9优先级运行(0以下都需要加 sudo)
    cookie  
    首行添加
    #！/usr/bin/python3
    修改程序权限添加可执行权限
    chmod  775  while.py

    可以直接指明路径执行
    ./while.py

    进程特征
    * 进程之间运行{相互独立}互不影响
    * 每个进程空间独立，各自占有一定的虚拟内存
    * 进程是操作系统分配{资源}的最小单元

要求：
1.什么是进程，进程和程序的区别
2.了解进程的特征和基本概念
3.理解并发并行的区别
4.清楚进程的每种状态，以及每种状态转换关系



7.多进程编程
  import os  
  os.fork 创建进程
  pid = os.fork()
  功能 ： 创建进程
  返回值：失败:返回一个负数
          成功:在原有进程中返回新进程的PID号
               在新进程中返回0
  * 父进程中fork返回值即为新创建子进程的PID号
  * 父子进程不一定谁先执行，执行上互不干扰抢占时间片 
  * 子进程会复制父进程全部代码段，包括fork之前产生的内存空间
  * 子进程从fork的下一句开始执行，与父进程互不干扰
  * 父子进程的执行顺序是不一定的，父子进程公用一个终端显示
  * 父子进程通常会根据fork返回值得差异选择执行不同的代码。所以if结构几乎是fork的固定搭配
  * 父子进程空间独立，操作的都是本空间的内容，互不影响
  * 子进程虽然复制父进程内容，但是也有自己的特有属性特征。比如： PID号 PCB 内存区间等
获取进程PID
os.getpid()
功能：获取当前进程的PID号
返回值：返回进程的PID号

os.getppid()
功能：获取当前进程父进程的PID号
返回值 ： 返回父进程的PID号

进程退出
os._exit(status)
功能：退出一个进程
参数： 进程的退出状态  整数

sys.exit([status])
功能 ： 退出一个进程
参数 ： 默认为0
        如果传入一个整数则同 _exit()
        传入一个字符串。则在对出时打印该字符串
* sys.exit() 可以通过try...except...捕获 SystemExit异常阻止退出

  孤儿进程：父进程先与子进程退出，此时进程就称为孤儿进程。
  *孤儿进程会被操作系统指定的进程收养，系统进程就成为孤儿进程的新的父进程
  僵尸进程：子进程先于父进程退出，但是父进程没有处理子进程的退出状态，此时子进程就会成为僵尸进程
          *僵尸进程会滞留部分PCB信息在内存中，大量的僵尸进程会消耗系统的内存资源，所以要尽量避免僵尸进程产生

1.如何避免僵尸进程产生:
  *处理子进程退出状态：
  pid,status = os.wait()
  功能：在父进程中{阻塞等待}处理子进程退出
  返回值：pid 退出的子进程的PID号
          status 获取子进程退出状态 * 256
  获取原来退出状态
  os.WEXITSTATUS(status)

  pid,status = os.waitpid(pid,option)
  功能 ： 在父进程中阻塞等待处理子进程的退出
  参数 ： pid    -1  表示等待任意子进程退出
                 >0  表示等待对应PID号的子进程退出
          option   0 表示阻塞等待 
                 WNOHANG （wnohang） 表示非阻塞
  返回值：pid  退出的那个子进程的PID号
          status  子进程的退出状态
  *waitpid(-1,0)  ===> wait()

  * 父进程先退出----->创建二级子进程
    1.父进程创建子进程等待子进程退出
    2.子进程创建下一级子进程，然后立即退出
    3.二级子进程成为孤儿，处理具体工作

2.multiprocessing 模块创建进程
  1. 需要将要做的事情封装成函数
  2. 使用multiprocessing提供的类Process创建进程对象
  3. 通过进程对象属性设置和Process初始化函数对进程进行进程的设置，绑定要执行的函数
  4. 启动进程，会自动执行绑定的函数
  5. 完成进程的回收

* 使用multiprocessing创建进程子进程同样复制父进程的全部内存空间，之后有自己独立的空间，执行上互不干扰
* 子进程也是有自己特有的PID等资源
* 如果不使用join回收字进程，则子进程退出后会成为僵尸进程
* 使用multiprocessing创建子进程，一般父进程功能就是创建子进程回收子进程，所有事件交给子进程完成

1.创建进程对象
  Process（target,name,args,kwargs）
  功能： 创建进程对象
  参数： target ： 要绑定的函数
         name ： 给进程起的名称 （默认Process-1）
         args： 元组 用来给target函数(位置传参)
         kwargs : 字典  用来给target函数键值传参
  返回：进程对象
2.进程对象的其他属性方法：
  p.start()、p.join([timeout])、p.name、p.pid、p.is_alive()、p.daemon
  p.start()
    功能：启动进程 
    *target函数会自动执行，此时进程真正被创建
  p.join([timeout])
    功能：阻塞，等待回收子进程
    参数：超时时间
  p.name 获取进程名字
  p.pid : 创建的、新的进程的PID号
  p.is_alive()  判断进程生命周期状态，处于生命周期得到True，否则返回False
  p.daemon{守护进程}:(与LINIX 守护没有半毛钱的关系)
    格式：p.daemon = False or True
    默认为False，主进程退出不会影响子进程                     
    如果设置为True 则主进程退出时子进程也会结束
    * daemon 属性设置要在start() 前
    * 设置daemon为True 则一般不需要加join
      cookie
    获取文件大小
    size = os.path.getsize("./timg.jpeg")
  
注意：
如果多个子进程拷贝同一个父进程中的对象（如文件对象，套接字，队列，管道。。。），对象和网络或者文件相关联，那么父子进程会使用同一套对象属性，相互有一定的关联系。
如果是在创建子进程后单独创建的对象，则多个子进程各不相同

1创建自定义进程类
  1. 编写{类继承Process}
  2、编写自己的__init__，同时加在父类init方法
  3、重写run方法，可以通过生成的对象调用start自动执行该方法

2.多进程：
  优点：可以使用计算机多核，进行任务的并发执行，提高执行效率
        空间独立，数据安全
        运行不受其他进程影响，创建方便
  缺点：进程的创建和删除的过程中消耗的系统资源较多
  进程池技术：
    1.产生原因：如果有大量的任务需要多进程完成，而任务周期又比较短且需要频繁创建。此时可能产生大量进程频繁
      创建销毁的情况，消耗计算机资源较大
    2.原理：创建适当的进程放入进程池，用来处理待处理事件，处理完毕后进程不销毁，仍然在进程池中等待处理其他事件。进程的复用降低了资源消耗
    3.使用方法 ：
      1. 创建进程池，在池内放入适当数量的进程
      2. 将事件封装函数，放入到进程池等待队列
      3. 事件不断运行，直到所有放入进程池事件运行完成
      4. 关闭进程池，回收进程
    4.创建进程池的基本过程：
      from multiprocessing import  Pool
      Pool(processes)
        功能：创建进程池对象
        参数：表示进程池有多少进程
        返回 ： 进程池对象
      pool.apply_async(fun,args,kwds)
        功能 ： 将事件放入进程池执行
        参数： fun 要执行的事件函数
               args  以元组为fun传参
               kwds  以字典为fun传参
        返回值：返回一个事件对象，通过get()属性函数可以获取fun的返回值（创建进程池之前，设置）

      pool.close()
        功能: 关闭进程池，无法再加入事件
      pool.join()
        功能 ： 回收进程池
  
      pool.apply(fun,args,kwds)
        功能 ： 将事件放入进程池执行
        参数： fun 要执行的事件函数
               args  以元组为fun传参
               kwds  以字典为fun传参
      pool.map(func,iter)    map、filter.sort
        功能：将要执行的事件放入到进程池
        参数：func 要执行的函数
              iter 迭代对象，给func传参
        返回值：返回func的返回值列表


进程间通信（IPC）：
  由于进程间空间独立，资源无法共享，此时在进程间通信就需要专门的通信方法。
  进程间通信方法:管道、消息队列、共享内存、信号、信号量、套接字（应用比较频繁的）
  1.管道通信(Pipe)：
    通信原理：在内存中开辟管道空间，生成管道操作对象，多个进程使用“同一个”管道，即可通过对管道的读写操作进
              行通信。
    multiprocessing ---》 Pipe   内存 》 磁盘（读写）
    fd1,fd2 = Pipe(duplex = True)
    功能: 创建管道
    参数：默认表示双向管道
          如果设置为False则为单向管道
    返回值：两个管道对象，表示管道的两端
            如果是双向管道，都可以读写
            如果为单向管道，则fd1只读，fd2只写
    fd.recv()
    功能:从管道读取信息
    返回值：读取到的内容
    * 当管道为空则阻塞
    fd.send(data)
    功能: 向管道写入内容
    参数：要写入的内容
    *管道满时会阻塞
    *可以写入几乎所有的python数据(套接字 要求发送betys)
  2.消息队列
    1.队列：先进先出
    2.通信原理：在内存中建立队列数据结构模型。多个进程都可以通过队列存入内容，取出
             内容的顺序和存入顺序保持一致
    3.创建队列：
      q = Queue(maxsize = 0)
      功能 ：创建队列对象
      参数 ：maxsize ：默认表示系统自动分配队列空间
              如果传入正整数则表示最多存放多少条消息
      返回值:队列对象
        q.put(data,[block,timeout])
        功能：向队列中存入消息
        参数：data  存入的消息 （支持python数据类型）
              block 默认True 表示当队列满时阻塞
                    设置为False 则为非阻塞
              timeout  超时时间 
      data = q.get([block,timeout])
        功能: 获取队列消息
        参数：block  默认为True 表示队列空时阻塞
                     设置为False则表示非阻塞
              timeout 超时时间
        返回值：返回获取到的消息
      q.full()  判断队列是否为满
      q.empty() 判断队列是否为空
      q.qsize() 获取队列中消息数量
      q.close() 关闭队列
  3.共享内存(share memery)
    通信原理：在内存中开辟一段空间，存储数据，多个进程可见。进程可以写入输出，但每次写入共享内存中的内容都会覆盖之前的内容。对内存的读操作页不会改变内存中的内容
    from multiprocessing import Value，Array 
    obj = Value(ctype,obj)
    功能： 开辟共享内存空间
    参数： ctype  字符串  要转变的c的类型
            obj  共享内存的初始化数据
    返回值：返回共享内存对象

    obj.value  表示共享内存中的值
    shm = Array(ctype,obj)
      功能 ： 开辟共享内存空间
      参数 ： ctype ： 要转换的数据类型
              obj ： 要存入共享内存的数据              
              * 列表、字符串 表示要存入的内容，要求类型相同
              * 整数   表示要开辟几个单元的空间
      返回值:返回共享内存对象可迭代对象
      *可以通过遍历过户每个元素的值
       e.g

           管道         消息队列       共享内存 
开辟空间   内存          内存           内存

读写方式   两端读写     先进先出    每次覆盖上次内容
           双向/单向                   
效率       一般         一般            较高
应用      多用于父子   应用灵活广泛   复杂，需要同步
          进程                        互斥操作

信号通信：
    一个进程向另一个进程发送一个信号来传递某种讯息，接受者根据接受到的信号

kill -l 查看系统信号
kill -sig PID 向一个程序发送信号

关于信号
信号名称 ： 系统定义，名字或者数字
信号含义 ： 系统定义，信号的作用
默认处理方法 ：当一个进程接收到信号是，默认产生的效果
               终止进程 暂停进程  忽略发生

SIGHUP 连接断开
SIGINT CTRU-C
SIGOUT CTRU-\
SIGSTP CTRL-Z
SIGKILL 终止一个而进程
SIGTOP 暂停一个进程
SIGALRM 时钟信号
SIGCHILD 子进程状态改变时给父进程

python 发送信号
signal
os.kill(pid,sig)
功能 ： 发送一个信号给某个进程
参数： pid 目标进程
       sig 要发送的信号

signal.alarm(sec)
功能: 设置时钟信号  在一定时间后给自身发送SIGALRM信号，使自身终止
参数： sec  时间（秒）
* 一个进程中只能有一个时钟，后来的时候会覆盖前面的时间

程序的同步执行和异步执行
同步 ：按照顺序逐句执行，一步完成再做下一步
异步 ：程序在执行中利用内核功能帮助完成必要的辅助操作，不影响应用层持续执行
*信号是唯一的异步通信方法

signal.pause()
功能：阻塞进程，等待一个信号

signal.signal(sig,handler)
功能 ：处理信号
参数 ：sig  要处理的信号
        handler  信号处理方法
        可选值：SIG_DFL  表示使用默认方法处理
                SIG_IGN  表示忽略这个信号
                func   传入一个函数表示用指定函数处理               
               自定义函数格式 ： def func(sig,frame)
               sig：接收到的信号
               frame：信号结构对象

* signal函数也是一个异步处理函数。只要执行了该函数，则进程任意时候接收到相应信号都会处理。
* signal 是不能处理 SIGKILL SIGSTOP的
* 父进程中可以用 signal(SIGCHLD,SIG_IGN)将子进程的退出交给系统处理
* 信号是一种异步的进程间通信方法


信号量：
  给定一定的数量，对多个进程可见，并且多个进程根据信号量多少确定不同的行为
sem = Semaphore(num)
功能 ： 创建信号量对象
参数 ： 信号量的初始值
返回 ： 信号量对象

sem.get_value()  获取当前信号量的值 
sem.acquire()  将信号量数量减1   当数量为0则阻塞
sem.release()  将信号量数量加1 


同步互斥机制：
目的：解决对共有资源产生的资源争夺
临界资源：多个进程或者线程都能够操作的资源
临界区：操作临界资源的代码段

同步： 同步是一种合作关系，为完成某个任务，多进程或         者多线程之间形成一种协调，按照约定执行，相互         告知，共同完成任务。
互斥 ： 互斥是一种制约关系，当一个进程或者线程进入临         界区操作资源时采用上锁的方式，阻止其他进程操         作。直到解锁后才会让出资源


Event 事件

from multiprocessing import  Event

创建事件对象
e = Event()

事件阻塞
e.wait([timeout])
功能：使进程处于阻塞状态，直到事件对象被set

事件设置
e.set()
功能 : 让事件对象变为被设置状态

清除设置
e.clear()
功能 ： 使事件对象清除设置状态

事件判断 判断当前事件对象的状态
e.is_set() 


锁  Lock
multiprocessing --》 Lock
创建对象
lock = Lock()
lock.acquire()  上锁 
lock.release()  解锁
* 如果一个锁对象已经被上锁则再调用acquire会阻塞
with  lock:    上锁
    ....
    ....
               解锁
  

多线程
什么是线程 （thread）
线程也是一种多任务编程方式，可以使用计算机的多核资源。线程被称为轻量级的进程。

线程特征： 
* 一个进程可以包含多个线程
* 线程是计算机多核分配的最小单位
* 线程也是一个运行过程，也要消耗计算机资源，多个线程共享共用进程的资源
* 线程的创建删除消耗的资源要远远小于进程
* 多个线程之间独立运行互不干扰
* 线程也有自己的特征属性，比如指令集 TID，线程栈


threading 模块的使用
threading.Thread()
功能: 创建线程对象
参数：target  线程函数
      name   线程名称 默认Thread-1... 
      args  元组   给线程函数位置传参
      kwargs  字典  给线程函数键值传参
返回：线程对象

t.start()  启动线程
t.join([timeout])  回收线程

线程对象属性
t.name 线程名称
t.setName()  设置线程名称
t.is_alive()  查看线程状态
threading.currentThread()  获取到当前线程对象

t.daemon 属性
默认情况下主线程结束不会影响分支线程执行
设置为True时主线程退出则分支线程也退出

设置 daemon值
t.setDaemon(True)
t.daemon = True

查看daemon值
t.isDaemon()

创建自己的线程类
步骤 ： 
1 继承 Thread
2 加载父类 __init__
3 重写run


线程通信：
  通信方法：多个线程共享进程的空间，所以线程间通信使用全局变量完成。
  注意事项：线程间使用全局变量往往要用不互斥机制保证通信安全
线程同步异步互斥方法：
  线程的event
  e = threading.Event() 创建事件对象
  e.wait([timeout]) 如果e为设置状态则不阻塞否则阻塞
  e.set() 将e变为设置状态
  e.clear() 清除设置 

进程线程的区别和联系
  1.两者都是多任务编程方式，都能够使用计算机的多核资源
  2.进程的创建、删除消耗的计算机资源比线程要多
  3.进程空间独立，数据数据相互不干扰，有专门的IPC，线程使用全局变量进行通信
  4.一个进程可以创建多个线程分支，

  ***********************缺*************

6.进程线程在系统中都有自己特有的属性，ID，代码段，栈区等资源

使用场景
*需要创建较多并发，同时任务关联性比较强时一般用多线程
*不同的任务模块可能更多使用进程
*使用进程线程需要考虑数据的处理复杂度，比如进程间通信是否方便，同步互斥是否过于复杂

要求：
1.进程线程的区别和联系
2.进程间通信方式都知道哪些，有什么特点
3.同步互斥意义是什么，什么情况下用
4.给一个情形，分析下用进程还是线程，理由
5.一些常见概念挖掘：僵尸进程，进程状态，GIL

服务器模型：
硬件服务器： 主机 集群
广商：IBM HP 联想 浪潮


软件服务器：编程的服务



httoserver ----> 处理http请求
webserver ---> 网站的后端应用服务器程序
邮箱服务器 ---> 邮件处理
ftp文件服务器 --> 文件的上传下载

功能：网络连接 逻辑处理 数据交互 数据传输 协议的实现

结构：c/s 客户端服务器模型
      b/s 浏览器服务器模型

服务器目标：处理速度更快，并发量更高，安全性能更强

硬件：更高的配置，更高的集成分布技术，更好的网络优化和网络安全技术

软件：占用资源更少，运行更稳定，算法更优良，安全性更好，并发性更高，更容易扩展

循环模型：循环接收客户端请求，处理请求。同一时刻只能处理一个请求，处理完毕后再处理下一个
    优点：实现简单，占用资源少
    缺点：无法同时处理多个客户端任务
    适用情况：处理任务可以短时间完成，不需要建立并发，更适合UDP适用
并发模型：能够同时处理多个客户端请求
        IO并发：IO多路复用
          优点：资源消耗少，IO处理速度快
          缺点：不能适用CPU密集型程序

        多进程/多线程并发：为每个客户端创建单独的进程线程，执行请求
        优点：每个客户端可以长期占有服务器运行程序，能够使用多核资源，可以处理IO或者CPU运算
        缺点：消耗系统资源高

多进程并发模型:
  使用fork实现多进程并发
  1.创建套接字，绑定，监听
  2.等待接收客户端请求
  3.创建新的进程处理客户端请求
  4.原有进程继续等待接收新的客户端连接
  5.如果客户端退出则关闭子进程

cookie:
在父进程中忽略子进程状态改变，子进程退出自动由系统处理

ftp文件服务器

项目功能
*服务端和客户端两部分，要求启动一个服务端，可以同时处理多个客户端请求
*功能：1.可以查看服务端文件库所有的普通文件
       
       2.从客户端可以查看下载文件库的文件到本地
       3.可以将本地文件上传的服务端文件库
       4.退出
*客户端使用print在终端打印简单的命令提示，通过命令提示发起请求

1.技术分析（fork TCP并发）
2.每个功能要单独封装，整体功能卸载一个类中
3.如何搭建整体架构，完成网络通讯

功能分析
1.获取文件列表
  客户端：*发送文件请求
          *得到回复判断能否获取列表
          *接收文件名称列表打印
  服务端：*接收请求
          *判断请求类型
          *判断能否满足请求，回复信息确认
          *执行请求发送文件列表
2.文件下载
  客户端：*发送请求（文件名）
          *得到回复判断能否下载
          *下载文件
  服务端：*接收请求
          *判断请求类型
          *判断能否满足请求，

cookie：
  os.listdir(path) #获取目录文件列表
  os.path.isfile() 判断是否为普通文件
  os.path.isdir() 判断是否为目录


多线程并发

threading 的多线程并发

对比多进程并发：
    * 消耗资源较少
    * 线程应该更注意共享资源的操作
    * 在python中应该注意GIL问题，网络延迟较高，线程并发也是一种可行的办法

实现步骤
    1. 创建套接字，绑定监听
    2. 接收客户端请求，创建新的线程
    3. 主线程继续接收其他客户端连接
    4. 分支线程启动对应的函数处理客户端请求
    5. 当客户端断开，则分支线程结束

cookie
import traceback

traceback.print_exc()
功能 ： 更详细的打印异常信息


集成模块的使用
python2 SocketServer
python3 socketserver

功能 ： 通过模块的不同类的组合完成多进程/多线程 的           tcp/udp的并发

StreamRequestHandler  处理tcp套接字请求
DatagramRequestHandler  处理udp套接字请求

TCPServer  创建tcp server
UDPServer  创建udp server

ForkingMixIn   创建多进程
ForkingTCPServer -->  ForkingMinIn + TCPServer
ForkingUDPServer -->  ForkingMinIn + UDPServer

ThreadingMixIn  创建多线程
ThreadingTCPServer --> ThreadingMinIn + TCPServer
ThreadingUDPServer --> ThreadingMinIn + UDPServer
 

HTTPServer  V2.0

1. 接收客户端请求
2. 解析客户端请求
3. 组织数据，形成HTTP response 
4. 将数据发送给客户端

升级
1. 采用多线程并发接收多个客户端请求
2. 基本的请求解析，根据请求返回相应的内容
3. 除了可以请求静态网页，也可以请求简单的数据
4. 将功能封装在一个类中

技术点 ：
1. socket  tcp 套接字
2. http协议的请求响应格式
3. 线程并发的创建方法
4. 类的基本使用


协程基础

定义 ： 纤程，微线程。协程的本质是一个单线程程序，所以协程不能够使用计算机多核资源。

作用 ： 能够高效的完成并发任务， 占用较少的资源。因         此协程的并发量较高


原理 ： 通过记录应用层的上下文栈区，实现在运行中进行上下文跳转，达到可以选择性地运行想要运行的部分，以此提高程序的运行效率。


优点 ： 消耗资源少
        无需切换开销
  无需同步互斥
  IO并发性好

缺点 ： 无法利用计算机多核

yield ---》 协程实现的基本关键字


greenlet

greenlet.greenlet()  生成协程对象
gr.switch() 选择要执行的协程事件

gevent

1. 将协程事件封装为函数
2. 生成协程对象
  gevent.spawn(func,argv)
  功能 ： 生成协程对象
  参数 ： func  协程函数
          argv  给协程函数传参
  返回值 ： 返回协程对象

3.回收协程
  gevent.joinall()
  功能 ： 回收协程
  参数： 列表 将要回收的协程放入列表

 gevent.sleep(n)
 功能： 设置协程阻塞，让协程跳转
 参数： n  阻塞时间

from gevent import monkey
monkey.patch_all()
功能: 修改套接字的IO阻塞行为

* 必须在socket导入之前使用












逻辑 算法
编程能力 进程，线程
语法 细节
项目