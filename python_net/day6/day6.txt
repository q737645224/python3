前情回顾

1.孤儿进程  僵尸进程
2.聊天室
3.multiprocessing
  Process   start   join
****************************************************
Process（target,name,args,kwargs）
name : 给进程起名字
       默认为Process-1 Process-2.....
       p.name 可以获取进程名称
args : 以元组的形式给target函数传参
kwargs ：以字典的形式给对应键的形参传参

进程对象的其他属性方法
p.name  p.start()  p.join() 
p.pid : 创建的、新的进程的PID号
p.is_alive()  判断进程生命周期状态，处于生命周期得到True，否则返回False
p.daemon{守护进程}:(与LINIX 守护没有半毛钱的关系)
  格式：p.daemon = False or True
  默认为False，主进程退出不会影响子进程                     
  如果设置为True 则主进程退出时子进程也会结束
  * daemon 属性设置要在start() 前
  * 设置daemon为True 则一般不需要加join
    cookie
  获取文件大小
  size = os.path.getsize("./timg.jpeg")
  注意：
  如果多个子进程拷贝同一个父进程中的对象（如文件对象，套接字，队列，管道。。。），对象和网络或者文件相关
  联，那么父子进程会使用同一套对象属性，相互有一定的关联系。
  如果是在创建子进程后单独创建的对象，则多个子进程各不相同


1创建自定义进程类
  1. 编写{类继承Process}
  2、编写自己的__init__，同时加载父类init方法
  3、重写run方法，可以通过生成的对象调用start自动执行该方法
2.多进程：
  优点：可以使用计算机多核，进行任务的并发执行，提高执行效率
        空间独立，数据安全
        运行不受其他进程影响，创建方便
  缺点：进程的创建和删除的过程中消耗的系统资源较多
  进程池技术：
    1.产生原因：如果有大量的任务需要多进程完成，而任务周期又比较短且需要频繁创建。此时可能产生大量进程频繁
      创建销毁的情况，消耗计算机资源较大
    2.原理：创建适当的进程放入进程池，用来处理待处理事件，处理完毕后进程不销毁，仍然在进程池中等待处理其他事件。进程的复用降低了资源消耗
    3.使用方法 ：
      1. 创建进程池，在池内放入适当数量的进程
      2. 将事件封装函数，放入到进程池等待队列
      3. 事件不断运行，直到所有放入进程池事件运行完成
      4. 关闭进程池，回收进程
    4.创建进程池的基本过程：
    from multiprocessing import  Pool
    Pool(processes)
      功能：创建进程池对象
      参数：表示进程池有多少进程
      返回 ： 进程池对象
    pool.apply_async(fun,args,kwds)
      功能 ： 将事件放入进程池执行
      参数： fun 要执行的事件函数
             args  以元组为fun传参
             kwds  以字典为fun传参
      返回值：返回一个事件对象，通过get()属性函数可以获取fun的返回值（创建进程池之前，设置）

    pool.close()
      功能: 关闭进程池，无法再加入事件
    pool.join()
      功能 ： 回收进程池
  
    pool.apply(fun,args,kwds)
      功能 ： 将事件放入进程池执行
      参数： fun 要执行的事件函数
             args  以元组为fun传参
             kwds  以字典为fun传参
    pool.map(func,iter)    map、filter.sort
      功能：将要执行的事件放入到进程池
      参数：func 要执行的函数
            iter 迭代对象，给func传参
      返回值：返回func的返回值列表


进程间通信（IPC）：
  由于进程间空间独立，资源无法共享，此时在进程间通信就需要专门的通信方法。
  进程间通信方法:管道、消息队列、共享内存、信号、信号量、套接字（应用比较频繁的）
  1.管道通信(Pipe)：
    通信原理：在内存中开辟管道空间，生成管道操作对象，多个进程使用“同一个”管道，即可通过对管道的读写操作进
              行通信。
    multiprocessing ---》 Pipe   内存 》 磁盘（读写）
    fd1,fd2 = Pipe(duplex = True)
    功能: 创建管道
    参数：默认表示双向管道
          如果设置为False则为单向管道
    返回值：两个管道对象，表示管道的两端
            如果是双向管道，都可以读写
            如果为单向管道，则fd1只读，fd2只写
    fd.recv()
    功能:从管道读取信息
    返回值：读取到的内容
    * 当管道为空则阻塞
    fd.send(data)
    功能: 向管道写入内容
    参数：要写入的内容
    *管道满时会阻塞
    *可以写入几乎所有的python数据(套接字 要求发送betys)
  2.消息队列
    1.队列：先进先出
    2.通信原理：在内存中建立队列数据结构模型。多个进程都可以通过队列存入内容，取出
             内容的顺序和存入顺序保持一致
    3.创建队列：
      q = Queue(maxsize = 0)
      功能 ：创建队列对象
      参数 ：maxsize ：默认表示系统自动分配队列空间
              如果传入正整数则表示最多存放多少条消息
      返回值:队列对象
        q.put(data,[block,timeout])
        功能：向队列中存入消息
        参数：data  存入的消息 （支持python数据类型）
              block 默认True 表示当队列满时阻塞
                    设置为False 则为非阻塞
              timeout  超时时间 
      data = q.get([block,timeout])
        功能: 获取队列消息
        参数：block  默认为True 表示队列空时阻塞
                     设置为False则表示非阻塞
              timeout 超时时间
        返回值：返回获取到的消息
      q.full()  判断队列是否为满
      q.empty() 判断队列是否为空
      q.qsize() 获取队列中消息数量
      q.close() 关闭队列
  3.共享内存(share memery)
    通信原理：在内存中开辟一段空间，存储数据，多个进程可见。进程可以写入输出，但每次写入共享内存中的内容都会覆盖之前的内容。对内存的读操作页不会改变内存中的内容
    from multiprocessing import Value，Array 
    obj = Value(ctype,obj)
    功能： 开辟共享内存空间
    参数： ctype  字符串  要转变的c的类型
            obj  共享内存的初始化数据
    返回值：返回共享内存对象

    obj.value  表示共享内存中的值
    shm = Array(ctype,obj)
      功能 ： 开辟共享内存空间
      参数 ： ctype ： 要转换的数据类型
              obj ： 要存入共享内存的数据      	      
      	      * 列表、字符串 表示要存入的内容，要求类型相同
      	      * 整数   表示要开辟几个单元的空间
      返回值:返回共享内存对象可迭代对象
      *可以通过遍历过户每个元素的值
       e.g

           管道         消息队列       共享内存 

开辟空间   内存          内存           内存

读写方式   两端读写     先进先出    每次覆盖上次内容
           双向/单向                   
效率       一般         一般            较快
应用      多用于父子   应用灵活广泛   复杂，需要同步
          进程                         互斥操作
作业 ： 熟练进程间通信和进程池的使用
        复习类的使用
        对进程使用和原理进行总结


