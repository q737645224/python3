Day06

15.矢量化
def 标量函数(标量1, 标量2, ...):
	...
	return 标量
矢量函数 = np.vectorize(标量函数)
矢量函数(矢量1, 矢量2, ...)
-> 由标量函数针对每一组矢量元素的返回值组成的矢量
代码: vec.py
	  sim.py(用历史数据模拟自动交易)


16.数据平滑与特征值
		降噪
--------------------------
卷积降噪 -> 曲线拟合 -> 特征值
(基于数据方程求曲线上的特殊点)

消除随机噪声干扰->获得数学模型(方程系数)->反映业务特征的值(比如极值点)
两个方程求交点:
y = f(x) -> y1 = f(x1)
y = g(x) -> y1 = g(x1)
f(x1) = g(x1)
f(x1) - g(x1) = 0
f(x)-g(x)=0 的根就是x1
np.polysub(p1,p2) -> p3 
#p1是f(x)的系数,p2是g(x)的系数,p3是f(x)-g(x)的系数
np.roots(p3) - x1
代码: smr.py


五.矩阵和ufunc
1.矩阵
ndarray -> matrix
ndarray里派生出一个matrix子类,matrix(矩阵)只能是二维的
但matrix里包含了矩阵的特殊性质,比如逆和矩阵乘法法则.

三种获得matrix对象的方法:
1.
numpy.matrix(可被解释为矩阵的二维容器,copy=True/False)
-> 矩阵对象
#二维容器可以是二维列表,元组,数组
#因为是ndarray的子类,所以ndarray的性质它也都继承了,比如元素都要同质等
#copy默认是True,指把原数据拷贝一份;False就是共享原来的数据

也可以通过字符串的形式获得一个二维数组:
1 2 3
4 5 6
'1 2 3; 4 5 6'		#空格表示列分割,分号表示行分割

2.
numpy.mat(可被解释为矩阵的二维容器)
一定是数据共享,相当于copy=False的matrix()

3.
numpy.bmat('A B; C D')
A: 1 2
   3 4
B: 5 6
   7 8
C: 9 10
  11 12
D:13 14
  15 16
 1   2   5   6
 3   4   7   8
 9   10  13  14
 11  12  15  16

matrix的属性:
T - 转置
I - 逆				#矩阵的逆矩阵

A x B = E  1 0 0	#A乘以A的逆矩阵,得到单位矩阵E
           0 1 0
           0 0 1
B = A.I

a = np.array([
	[1, 2],
	[3, 4]])
b = np.array([
	[5, 6],
	[7, 8]])
c = a * b     	#数组相乘就是对应元素相乘
 5 12
21 32

a = np.mat([
	[1, 2],
	[3, 4]])
b = np.mat([
	[5, 6],
	[7, 8]])
c = a * b
19 22
43 50

矩阵乘法原则记忆法:
	  A D
	  B E
	  C F
a b c m n
d e f o p

m = aA+bB+cC
n = aD+bE+cF
o = dA+eB+fC
p = dD+eE+fF

矩阵乘法是不遵守交换律的:
	a b c
	d e f
A D m n o
B E p q r
C F s t u

m = Aa+Dd
n = Ab+De
....

代码: mat.py


2.ufunc, 统一化函数
1)numpy.frompyfunc(标量函数, 参数个数,返回值个数)
-> numpy.ufunc类型的函数对象
ufunc函数对象(矢量参数,...)-> 矢量返回值,...
#用frompyfunc创建的函数总是返回python对象数组
代码:vec2.py

下面是几个预定义的ufunc对象
2)numpy.add
reduce - 累加
accumulate - 累加过程
reduceat - 在指定位置累加
outer -  外和
代码:add.py


3)除法
A.真除
[5 5 -5 -5]<真除>[2 -2 2 -2]=[2.5 -2.5 -2.5 2.5]
numpy.true_divide()
numpy.divide()
/

B.地板除				#向下取整
[5 5 -5 -5]<地板除>[2 -2 2 -2]=[2 -3 -3 2]
numpy.floor_divide()
//

C.天花板除
[5 5 -5 -5]<天花板除>[2 -2 2 -2]=[3 -2 -2 3]

D.截断除				#去掉小数部分
[5 5 -5 -5]<截断除>[2 -2 2 -2]=[2 -2 -2 2]
代码: div.py


4)余数
被除数<除以>除数=商...余数
除数x商+余数=被除数
地板余数:				#做地板除所得到的余数
[5 5 -5 -5]<地板除>[2 -2 2 -2]=
				   [2 -3 -3 2]...[1 -1 1 -1]
numpy.remainder()
numpy.mod()
%

截断余数
[5 5 -5 -5]<截断除>[2 -2 2 -2]=
				   [2 -2 -2 2]...[1 1 -1 -1]
numpy.fmod()
总结: 不同的商对应不同的余数
代码: mod.py
python中几乎所有的算术和关系运算符都被numpy借助ufunc时限为可对数组操作的矢量化运算符.


利用矩阵乘方的方法来求斐波那契的第n项:
     1 1   1 1   1 1
     1 0   1 0   1 0
1 1  2 1   3 2   5 3         	#取矩阵(0,0)那个元素
1 0  1 1   2 1   3 2  .....
f1f2 f3    f4    f5        fn   #(n-1)次方
     F^2   F^3			  F^(n-1)
代码: fibo.py


5)numpy中的三角函数都是ufunc对象,可以对参数数组中的每个元素进行三角函数运算,并将结果以数组形式返回.
在水平和垂直方向上有两个不同振幅,频率和初相位的简谐振动,求它们合成以后的运动轨迹(利萨如曲线)
简谐振动:物体在与位移成正比的恢复力作用下,在其平衡位置附近按正弦规律做往复的运动.
x = Asin(at+pi/2)
y = Bsin(bt)
#A是振幅,a是角频率,pi/2是初相位
#问题就变成x和y关于时间t的正弦函数
代码: lissa.py

把不同频率和振幅的正弦信号相叠加:
 4     sin((2k-1)t)
--- x --------------
pi          2k-1
k = 1,2,3...
#把几个信号累加,这个就是方波的傅里叶展开公式
代码: squr.py


6)实现位运算的ufunc
A.异或: ^ / __xor__ / bitwise_xor
1 ^ 0 = 1
1 ^ 1 = 0
0 ^ 0 = 0
0 ^ 1 = 1
if a^b < 0 then a和b异号

B.与(位与): & / __and__ / bitwise_and
1 & 0 = 0
1 & 1 = 1
0 & 0 = 0
0 & 1 = 0
  1	 2^0 00000001 -1 -> 00000000
  2  2^1 00000010 -1 -> 00000001
  4  2^2 00000100 -1 -> 00000011
  8  2^3 00001000 -1 -> 00000111
  16 2^4 00010000 -1 -> 00001111
             \____&______/
                  |
                  0
if a & (a-1) == 0 then a是2的幂

C.移位: << / __lshift__ / left_shift		(乘2)
		>> / __rshift__ / right_shift		(除2)
代码:bit.py


六.Numpy的子模块
1.线性代数模块(linalg)
1)矩阵的逆: inv()
使用numpy.linalg.inv()函数求矩阵的逆矩阵,要求必须是方阵,即行列数相等的矩阵.
代码: inv.py

2)解线性(一次)方程组: solve()
/ x-2y+z = 0
| 2y-8z-8 = 0
\ -4x+5y+9z+9 = 0
x-7z-8=0
5x-10y+5z=0
-8x+10y+18z+18=0
-3x+23z+18=0
3x-21z-24=0
2z-6=0 -> z=3
x = 21+8 =29
29-2y+3=0 -> y=16
方程组做如下转化:
/ 1x + -2y + 1z = 0
| 0x + 2y + -8z = 8
\ -4x + 5y + 9z = -9
/ 1 -2 1 \   / x \   / 0 \
| 0 2 -8 | X | y | = | 8 |
\ -4 5 9 /   \ z /   \-9 /
----------   -----   ------
    a          x       b
    = numpy.linalg.lstsq(a, b)[0]
    = numpy.linalg.solve(a, b)
lstsq在方程数多于未知变量时,会求出近似解,并给出残差
solve在方程数多于未知变量时,会抛出异常,只能求精确解
代码: solve.py


3)特征值和特征向量:
对于n阶方阵A,如果存在数a和非零n维向量x,使得Ax=ax,则称a是矩阵A的一个特征值,x是矩阵A属于特征值a的特征向量.
numpy.linalg.eig(A) -> a, x
代码: eig.py


4)奇异值分解:
对于一个满足特定条件的矩阵M,可以被分解为三个矩阵的乘积,M=USV,其中U和V都是正交矩阵,即UU^T=I,VV^T=I(I指单位阵),S矩阵除主对角线以外的元素均为0,主对角线上的元素被称为矩阵M的奇异值.
numpy.linalg.svd(M) -> U, S主对角线上的元素, V
代码: svd.py

5)广义逆矩阵: pinv()
代码:pinv.py

6)行列式:
a b
c d
ad-bc			#计算行列式的值

a b c
d e f
g h i
a e f - b d f + c d e
  h i     g i     g h
a(ei-fh)-b(di-fg)+c(dh-eg)
numpy.linalg.det(方阵) -> 行列式的值	#标量
代码: det.py