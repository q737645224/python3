Day04

3.加权平均值
样本S: [s1, s2, s3 ... sn]
权重W: [w1, w2, w3 ... wn]
加权平均值a=(s1w1+s2w2+...+snwn)/(w1+w2+...+wn)
sw = w1+w2+...+wn
a = s1w1/sw+s2w2/sw+...+snwn/sw
numpy.average(样本数组, weights=权重数组)
当各样本的权重相等时,加权平均值就是算数平均值.

计算VWAP(Volume Weighted Average Price, 成交量加权平均价格,量化金融中常用的指标)
代码:vwap.py

计算TWAP(Time Weighted Average Price,
时间加权平均价格,用历史的价格对未来的价格做预判)
代码:twap.py


4.最大值,最小值和极差
1)max/min: 在一个数组的各个元素中寻找最大或最小元素.
a:
9 7 5
3 1 8
6 6 1
a.max() -> 9
a.min() -> 1

2)maximum/minimum: 在两个数组之间对应位置最大值或最小值的集合数组.
(只能两个参数,且维度要相同)
a:
9 7 5
3 1 8
6 6 1
b:
6 1 9
7 1 7
4 4 5
np.maximum(a, b) ->
9 7 9
7 1 8
6 6 5

3)ptp: max - min  #极差,最大值减最小值
np.ptp()
代码: max.py

实际案例:
价格范围和价格幅度
价格范围: 在一定时期内最高的最高价和最低的最低价之差.
价格幅度: 在一定时期内最高价的极差和最低价的极差.
		(在高水平震动的带宽和低水平震动的带宽)
代码: range.py


5.中位数
(样本中可能会有个别样本明显偏离均值,中位数可以排除这些个别样本的干扰)
将多个样本排序,排序以后位于中间位置的元素成为中位数.
10 30 50 70 90		#奇数序列,中间元素
	  ^
	  中
10 30 50 70			#偶数序列,中间两个元素的算数平均值
	^ ^
	---
	40
	中
A: 序列
L: 序列长度,元素个数
M = (A[int((L-1)/2)] + A[int(L/2)]) / 2	
#int()去除小数部分
np.median(有序或无序数组)
代码:med.py


6.标准差		(重点看)
样本: S = [s1, s2, ..., sn]
均值: m = (s1+s2+...+sn) / n
离差: D = [d1,d2,...,dn], di=si-m #样本偏离均值的差
离差方:Q = [q1,q2,...,qn], qi=di^2	#去掉正负
(总体)方差:v = (q1+q2+...+qn)/n   #对离差方取均值
(总体)标准差: s = sqrt(v)		  #方均根
np.std(样本数组) -> 标准差
(样本)方差:v = (q1+q2+...+qn) / (n-1)
(样本)标准差:s = sqrt(v)
#每个样本对噪声的贡献值,只有(n-1)个样本是自由变化的
#第n个样本没有变化自主性,当样本足够多时,两种方法近似相等
代码:std.py


7.星期数据
1)通过date.weekday()方法可以获得用0到6表示的星期一到星期日,将文本形式的星期量转化为数字(整数)
2)根据给定的条件,从数组中拣选满足该条件的元素:
A.被拣选数组[条件表达式]
B.被拣选数组[np.where(条件表达式)]
C.np.take(被拣选数组, np.where(条件表达式))
代码: week.py

3)轴向扩展
把一个标量化的操作变成一个矢量化的操作
def fun(标量1, 标量2, 标量3):
	...
	return 标量4
np.apply_along_axis(fun, 轴向0/1/2, 矢量1,矢量2,矢量3)
-> 矢量4
代码: axis.py

实际案例:
按周汇总
代码: sum.py


8.卷积运算    	 (重点看)
卷积的应用介绍:
统计学中,加权的滑动平均是一种卷积.
概率论中,两个统计独立变量X和Y的和的概率密度函数是X与Y的概率密度函数的卷积.
声学中,回声可以用源声与一个反映各种反射效应的函数的卷积表示.
电子工程与信号处理中,任一个线性系统的输出都可以通过将输入信号与系统函数(系统的冲激响应)做卷积获得.
物理学中,任何一个线性系统(符合叠加原理)都存在卷积.
计算机科学中,卷积神经网络(CNN)是深度学习算法中的一种,近年来被广泛用到模式识别,图像处理等领域中.

数组卷积: np.convolve(被卷积数组,卷积核数组,卷积类型)
a:[1 2 3 4 5]			#被卷积数组
b:[6 7 8]				#卷积核数组
#卷积运算时,是用卷积核数组b的逆序列运算
c = np.convolve(a, b, 'full')	#完全卷积
c: [6  19 40 61 82 67 40]
c = np.convolve(a, b, 'same')	#同维度卷积,c与a维度
c: [19 40 61 82 67]
c = np.convolve(a, b, 'valid')	#有效卷积(不需要补0)
c: [40 61 82]

	  6  19 40 61 82 67 40		#卷积结果(相乘再相加)
0  0  1  2  3  4  5  0  0
8  7  6
   8  7  6
   	  8  7  6
         8  7  6
            8  7  6
               8  7  6
                  8  7  6
代码: conv.py

移动均线(MA, Moving Average)
一般用收盘价来计算移动均线.
根据窗口大小,比如5日均线,窗口每次移动一日,算一个均值,连成一条趋势线.
窗口越大,对噪声的敏感度就越差,波动越小,时间滞后性越大.
s = a+b+c+d+e 		    		#权之和
(Aa+Bb+Cc+Dd+Ee)/s      		#加权和除以权之和
=Aa/s + Bb/s + Cc/s + Dd/s +Ee/s
[a/s b/s c/s d/s e/s]			#相当于卷积核
代码: ma.py

