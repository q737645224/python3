day05回顾:
  循环语句
    for 语句
    注：只能对可迭代对象 进行访问
        语法:
          for 变量列表（自定义变量）  in 可迭代对象:
              语句块1
          else:
              语句块2
    range() 函数返回整数（整数生成器）
    range(开始:结束：步长)
    
    可迭代对象: 
     注：序列都为可迭代对象
       字符串（str）{不可变容器}  列表（list）[可变容器][有序序列]
       range(开始值，结束值，步长)
       列表 list    #元祖tuple[不可变，有序序列] 字典dict[key:value]  集合 set 
       （包含以后所学的全部的容器类)
    continue语句
      重用开始一次新的循环
        for, while 开始的位置不同
  容器类
    列表 list
      是可变的序列
      也是容器
    字面值表示方式:
      []
    列表的构造(创建)函数
       list()
       list(可迭代对象)
    列表的运算:
      + += * *=
      注意:
        变量名 += 可迭代对象
      < <= > >= ==!=
      

















day06笔记：
列表的in / not in 运算符
 判断一个值是否存在于列表中，如果存在返回True，否则反回False
 同字符串的in运算符
 用于检查一个值是否存在于列表中，如果存在返回True，否则反回False

列表的索引操作：
  语法:
    列表[整数表达式]
  用法:
    等同于字符串的索引操作(索引分正向索引和反向索引，规则与字符串完全相同)

  列表的索引赋值
    列表是可变的序列，可以通过索引赋值改变列表中的元素
    语法:
      列表[整数表达式] = 表达式
  示例见:
      x = [1, 2, 3, 4]
      x[2] = 3.14 #改变了第三位的值
    list_index.py



 列表的切片
   列表[:]
   列表[::]
   列表的切片取值返回一个列表,规则等同于字符串的切片规则
  例如:
    L = [0, 1, 2, 3, 4, 5, 6, 7, 8]
    L2 = L[1::2]  # L2 = [1, 3, 5, 7]

  列表的切片赋值:
    作用:
      可以改变原列表的排列，可以 插入 和  修改数据（增加or减少）
      可以用切片改变列表对应的元素的值
    语法:
      列表[切片slice] = 可迭代对象
          取出切片位子  《 放入取出位子 （不考虑取出与放入的元素个数是否相等） 
    说明:
      赋值运算符的右侧必须是一个可迭代对象
    示例:
      L = [2, 3, 4]
      L[0:1] = [1.1, 2.2]  # L = [1.1, 2.2, 3, 4]
      L[2:] = [3.3, 4.4, 5.5]  # L = [1.1, 2.2, 3.3, 4.4, 5.5]
      L[:] = [3, 4]
      


      L[0:0] = [1, 2]   #实现插入数据的方式    L[i:i]
      L = [3, 5]
      L[1:1] = [4.1, 4.2]  # [3, 4.1, 4.2, 5]
      
      L = [3, 5]
      L[2:2] = [6]  # L = [3, 5, 6]   #赋值 支持越界
      L = [3, 5, 6]
      

      L[1:2] = []  # 删除了中间的5
      L = [1, 6, 10]
      L[1:2] = range(2, 10)  # L = [1, 2, 3....10]
      L = ['D', 'E']
      L[:0] = "ABC"  # L = ['A', 'B', 'C', 'D', 'E']
      L = [1, 2, 3, 4, 5, 6]
      L[::2] = "ABC"
      L = [1, 2, 3, 4, 5, 6]
      L[::-2] = "DEF"
    

    注：增[i:i] 删 del L[i] 改L[i：i+1]=[]  查

    切片赋值注意事项:
      对于步长不等于1的切片赋值，赋值运算符的右侧的可迭代对象提供的数据元素的个数{一定要等于切片切出的片数}
    如:
      L = [1, 2, 3, 4, 5, 6]
      L[::2] = "ABC"  # 正确
      L[::2] = "ABCDE" #错误

    del 语句用于删除列表的元素
      语法:
        del 列表[索引]
        del 列表[切片]
      示例:
        L = [0, 1, 2, 3, 4, 5, 6]
        del L[0]  # L = [1, 2, 3, 4, 5, 6] 索引方式
        del L[::2] # L = [2, 4, 6]     切片方式



练习:
  已知有列表:
    L = [3, 5]

    1) 用索引和切片等操作，将原列表改变为:
    L = [ 1, 2,3, 4, 5, 6]
    
    2) 将列表反转,删除最后一个元素后打印此列表
       ...
       print(L)  # [6, 5, 4, 3, 2]

python3 中常用的序列相关的函数
  序列有5种：
    str, list, tuple(元组), bytes(字节), bytearray

  len(x)  返回序列的长度

  max(x)  返回序列的最大值元素
  min(x)  返回序列的最小值元素
  sum(x)  返回序列中所有元素的和(元素必须是数值类型)
  
  any(x)  真值测试,如果列表中其中一个值为真值则返回True
  all(x)  真值测试,如果列表中所有值为真值则返回True
  示例:
    L = ['北京', 100000, "天津"]
    len(L)  # 返回结果为3
    L = [8, 3, 6, 2]
    print(max(L))  # 8
    print(min(L))  # 2
    print(sum(L))  # 19

练习：
  1. 写程序，让用户输入一些整数，当输入-1时结束输入，将这些数存于列表L中
    1)  打印用户共输入了几个数？
    2)  打印您输入的数的最大数是多少
    3)  打印您输入的数的最小数是多少
    4)  打印您输入的这些数的平均值是多少？
  
  2.写一个程序，让用户输入很多个正整数，当输入小于零的数时结束输入
    1） 打印这些书中最大的一个数
    2） 打印这些书数中第二大的一个数
    3）删除最小的一个数
    4）按原来的顺序打印出剩余的这些数




列表中常用的方法(method)
  详见:
    >>> help(list)
  参见:
    python_base_docs_html/list.html


练习:
  输入多行文字，存入列表中,
  每次输入回车后算一行
    任意输入多行，当输入回车(即输入空行时结束输入)
  1) 按原输入内容在屏幕上输出内容
  2) 打印出您共输入了多少行文字
  3) 打印出您共输入了多少个字符





练习:
  1. 有字符串"hello"
    请用此字符串生成:
      'h e l l o' 和 'h-e-l-l-o'
    答案:
      s = "hello"
      a = ' '.join(s)  # a = 'h e l l o'
      b = '-'.join(s)  # b = 'h-e-l-l-o'

  2. 写一个程序，让用户输入很多正整数，当输入小于零的数时结束输入,
    1) 打印这些数中最大的一个数
    2) 打印这些数中第二大的一个数
    3) 删除最小的一个数
    4) 打印剩余数的和



浅拷贝  和 深拷贝
浅拷贝 shallow copy
  浅拷贝是指在复制过程中，只复制一层变量，不会复制深层变量绑定的对象的复制过程
  优点：节省内存，节省时间

示例:
  L = [3.1, 3.2]
  L1 = [1, 2, L]
  L2 = L1.copy()  # 浅拷贝
  L2[2][0] = 3.14
  print(L1)  # [1, 2, [3.14, 3.2]]
  print(L2)  # [1, 2, [3.14, 3.2]]

深拷贝 deep copy
  import copy  # 导入copy模块，以后再讲导入
  L = [3.1, 3.2]
  L1 = [1, 2, L]
  L2 = copy.deepcopy(L1)  # 深拷贝
  L2[2][0] = 3.14
  print(L1)  # [1, 2, [3.1, 3.2]]  #<<--此处不变
  print(L2)  # [1, 2, [3.14, 3.2]]

注:
  深拷贝通常只对可变对象进行复制，不可变对象通常不会复制

小结:
  L1 = [1, 2, [3.1, 3.2]]
  L2 = L1  # 不拷贝，创建一个变量同时绑定原对象
  L3 = L1.copy()  # 浅拷贝  等同于 L3 = L1[:]
  import copy
  L4 = copy.deepcopy(L1)  # 深拷贝


列表和字符串比较：
 1.都时序列，有先后顺序关系，有相同的运算操作
 2.列表是可变的，字符串是不可变的
 3.列表可以存在任意类型的数据，字符串只能存字符

 字符串的文本解析方法 split 和join
   S 代表字符串
  S.split(sep=None)  将字符串使用sep作为分隔符分割S字符串，返回分割后的字符串列表，当不给定参数时，用空白字符作为分隔符分割
  S.join(iterable)   用可迭代对象中的字符串，返回一个中间用S进行分隔的字符串

  示例:
    s = 'Beijing is capital'
    L = s.split(' ') # L = ['Beijing', 'is', 'capital']
    '\\'.join(['C:', 'Programe Files', 'python3'])


列表推导式 list comprehension
  列表推导式是   用可迭代对象生成[列表的表达式]

  作用:
    用简易方法生成列表
  语法:
    [表达式 for 变量 in 可迭代对象]
    或
    [表达式 for 变量 in 可迭代对象 if 真值表达式]
      4           2         1         3
  说明:
    for in 表达式的if子句可以省略，省略后将对所有生成的对象进行求值处理
  示例:
    # 生成一个数值为 1 ~ 9 的平方的列表
    L = [x**2 for x in range(1, 10)]
    L = [表达式 for x in 可迭代对象]
          3         2       1

输入一个开始的整数用begin绑定
输入一个结束整数用end绑定
将从begin开始，到end结束（不包括end）的所有偶数存于列表中并打印此列表
（可以使用列表推导式完成，也可以用循环语句来完成）


练习:
  用列表推导式生成1~100内奇数的列表
  结果是: [1, 3, 5, 7, ..... 99]

  L = [x for x in range(1, 100, 2)]

  示例:
    生成1~00内的奇数的列表:
  L = [x for x in range(1, 100) if x % 2 == 1]

练习:
  生成一个数值为 1 ~ 9的平方的列表，去掉所有的奇数的平方
    L = [x**2 for x in range(1, 10，2)]
    or

    # L = [4, 16, 36, 64]

列表推导式的嵌套:
  语法:
    [ 表达式
        for 变量1 in 可迭代对象1 if 真值表达式1
            for 变量2 in 可迭代对象2 if 真值表达式2]

    示例：将列表[10,20,30]中的元素与列表[1,2,3]元素分别相加，将得到的元素放于一个列表中
  示例:
    L = [x + y for x in "ABC" for y in "123"]


练习:
  1.用字符串"ABC"和字符串"123"生成如下列表
  ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']


  2.已知有一个字符串：
    S = '100，200， 300， 500， 800'
    将其转换为列表，列表的内部是整数
    L = [100,200,300,500,800]

3. 有一些数存于列表中:
    L = [1, 3, 2, 1, 6, 4, 2, ..... 98, 82]
    将列表中出现的数字存入到另一个列表L2中
      要求: 重复出现多次的数字在L2列表中只保留一份(去重)
      将列表中出下现两次的数字存于列表L3中(在L3列表中保留一份)

4.计算出100以内的素数，将这些素数存于列表中，最后打印出列表中的这些素数

5.生成前40个斐波那契数(Fibonacci)
      1  1  2  3  5  8  13  .....
      要求将这些数保存在列表中
      打印这些数

      def fib(max):
    n, a, b = 0, 0, 1
    while n < max:
        print(b)
        a, b = b, a + b
        n = n + 1
    return 'done'