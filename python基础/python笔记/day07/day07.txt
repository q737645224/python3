day06回顾:
  列表:
    是可变的序列
    是容器
  索引和切片操作
    列表可以索引赋值和切片赋值
  del 语句
    用于删除列表中的元素
        del 列表[整数表达式]
        del 列表[切片]
  序列相关的函数:
    len(x), max(x), min(x), sum(x), any(x), all(x)

  列表中的方法:
    L.index(v)   
    L.insert(index, obj)
    L.count(x)
    L.remove(x)
    L.copy()
    L.append(x)
    L.extend(lst)   # L += lst
    L.clear()
    L.sort()
    L.pop(索引)
    L.reverse()  列表的反转
  深拷贝deep copy , 浅拷贝 shallow copy

字符串的方法：
  str.split()  分割
  str.join()   连接

列表推导式 
  [x ** 2 / 7 for x in range(1, 10, 2) if ...]

  [x + y for x in [10, 20, 30] for y in range(10)]





day07 笔记
元组 tuple
  元组是不可变的序列，同list一样，元组可以存放任意类型数据的容器

元组的表示方法:
  用小括号() 括起来，单个元素括起来后加逗号(,)区分单个对象还是元组

创建空元组的字面值:
   t = ()   空元组

创建非空元组的字面值表示:
  t = 200,
  t = (20,)
  t = (1, 2, 3)
  t = 100, 200, 300

函数type(x) 用来返回x对应的类型
元组的错误示例:
  t = (20)  # t 绑定20这个对象，不是元组
  x, y, z = 100, 200, 300  # 序列赋值
  x, y, z = (100, 200, 300)  # 序列赋值
  x, y, z = [100, 200, 300]  # 序列赋值
  x, y, z = 'ABC'            # 序列赋值

元组的构造(创建)函数tuple
  tuple()   生成一个空元组，等同于()
  tuple(iterable)  用可迭代对象生成一个元组

  示例：
    t = tuple()   # 等同于 t = ()
    t = tuple(range(1, 10, 3))  # t = (1, 4, 7)
    t = tuple("ABC")  # t = ('A', 'B', 'C')
    t = tuple([1, 2, 3])  # t = (1, 2, 3)

元组的运算:
  + += * *=
  < <= > >= == !=
  in , not in
  索引[],切片[:]/[::]

+ 加号用于拼接元组
* 用于生成重复的元组

元组的比较运算:
  规则与列表的比较规则完全相同

in / not in 运算符
  规则与列表的规则完全相同

索引和切片
  索引取值和切片取值的规则与列表完全相同
  元组不支持索引赋值和切片赋值(因为元组不可被改变)

元组的方法:
  T.index(v[, begin[, end]]) 返回对应元素的索引下标
  T.count(x)  返回元组中对应的元素个数
  详见:
    >>> help(tuple)

序列相关的函数:
  len(x), max(x), min(x), sum(x), any(x), all(x)

构造函数:
  str(x)  创建字符串
  list(iterable) 创建列表 
  tuple(iterable) 创建元组

序列相关的函数:
  reversed(可迭代对象)  返回反向顺序的可迭代对象
  sorted(iterable, key=None, reverse=False) 返回已排序的列表

示例:
  t = (4, 8, 6, 2, 7)
  L = [x for x in reversed(t)]
  # L = [7, 2, 6, 8, 4]  # 原来先后顺序的反向
  for x in reversed(t):
      print(x)  #  打印: 7  2  6  8  4

  L2 = sorted(t)  # L2 = [2, 4, 6, 7, 8]
  L3 = sorted(t, reverse=True)  # L3 = [8, 7, 6, 4, 2]


容器小结:
  字符串 str   # 不可变序列，只能存字符
  列表 list    # 可变的序列，可以存任意数据
  元组 tuple   # 不可变序列，可以存任意数据



字典 dict

什么是字典:
  1. 字典是一种可变的容器，可以存储任意类型的数据
  2. 字典中的每个数据都是用'键'(key)进行索引，而不象序列可以用整数下标来进行索引
  3. 字典中的数据没有先后关系，字典的存储是无序的
  4. 字典中的数据以键(key)-值(value)对形式进行映射存储
  5. 字典的键不能重复，且只能用不可变类型作为字典的键

字典的字面值表示方法:
  字典的表示方式是以{} 括起来，以冒号(:) 分隔键-值对,各键-值对之间用逗号(,)分割开 

创建空字典的字面值:
  d = {}    # d 绑定空字典

创建非空字典的字面值:
  d = {'name': 'weimingze', 'age': 35}
  d = {1: 'One', 2: 'Two', 3: 'Three'}
  d = {'国籍': '中国'}
  d = {1: [1, 2, 3], 'abc': (1.1, 2.2, 2.3)}
  d = {123: list("123")}
  d = {'a': {'b': 200, 'c': [1, 2, 3]}}
  d = {(1970, 1, 1): 'computer year'}

字典的构造函数dict
  dict()  生成一个字的字典 等同于 {}
  dict(iterable)  用可迭代对象初始化一个字典
  dict(**kwargs)  用关键字传参形式创建一个字典

  示例:
    d = dict()
    d = dict([('name', 'tarena'), ['age', '15']])
    d = dict(name='tarena', age=15)

字典的键(key) 必须为不可变类型
  bool, int, float, complex, str, tuple, frozenset, bytes(后面再讲)

字典的值(value) 可以是任意类型
  
可变的数据类型有四种:
  list 列表
  dict 字典
  set  集合(后面才讲)
  bytearray 字节数组


字典的基本操作:
  字典的键索引
    用[] 运算符可以获取字典内'键'对应的值
    也可以用[] 运算符来修改'键'对应的值
  键索引的语法:
    字典[键]

  示例:
    获取值:
    d = {'name': 'tarena', 'age': 15}
    print(d['name'], '的年龄是:', d['age'])


添加/修改字典的元素
  语法:
    字典[键] = 值
  说明:
    键不存在时，创建键，并绑定对应的值
    当键存在时，修改键绑定的值
  示例:
    d = {}
    d['name'] = 'tarena'  # 创建新的键值对
    d['age'] = 15
    d['age'] = 16  # 修改'age'所对应的值
  
  删除字典元素
    del 字典[键]
  示例:
    d = {'name': 'tarena', 'age': 15}
    del d['name']
  

字典的成员资格判断 in 运算符
  可以用in运算符判断一个键是否存在于字典中，如果'键'存在则返回True,否则返回False
  not in 与 in 结果相反

  示例:
    d = {'name': 'tarena', 'age': 15}
    if 'name' in d:
        print('name 在字典中')

    print(15 in d)  # False,只判断键，不判断值


写程序，实现以下要求:
  1) 将如下数据形成一个字典seasons:
    '键'    '值'
     1      '春季有1, 2, 3月'
     2      '夏季有4, 5, 6月'
     3      '秋季有7, 8, 9月'
     4      '冬季有10,11,12月'
  2) 让用户输入一个整数，代表一个季度，打印这个季度对应的信息，如果用户输入的信息不在字典内，则打印信息不存在



字典的迭代访问
  字典是可迭代对象，字典只能对键进行迭代访问

  示例:
    d = {'name': 'tarena', 'age': 15}
    for k in d:
        print(k, '对应的值是: ', d[k])

可以用于字典的内建函数
  len(x) 返回字典的键值对个数
  max(x) 返回字典的键的最大值
  min(x) 返回字典的键的最小值
  sum(x) 返回字典中所有键的和
  any(x) 真值测试，只要有一个键为True,返回True
  all(x)  真值测试，当全部键为真值是，返回True

  示例:
    d = {0: '零', 5: '伍', 8: '捌', 3: '参'}
    print(len(d))  # 4
    print(max(d))  # 8
    print(min(d))  # 0
    print(sum(d))  # 16
    print(any(d))  # True
    print(all(d))  # False



练习:
  输入一段字符串，打印出这个字符串中出现过的字符的出现次数
  如:
    输入:
      abcdabcaba
    打印:
      a: 4次
      b: 3次
      d: 1次
      c: 2次
    注:
       不要求打印的顺序



字典推导式:
  字典推导式是用可迭代对象创建字典的表达式

  语法:
    {键表达式 : 值表达式 for 变量 in 可迭代对象 if 真值表达式}
  说明:
    if 子句部分可省略
  示例:
    生成一个字典，键为数字(10以内), 值为键的平方
    d = {x : x ** 2 for x in range(10)}

练习:
  有字符串的列表如下:
    L = ['tarena', 'xiaozhang', 'tyke']
    用上述列表生成如下字典:
      d = {'tarena': 6, 'xiaozhang': 9, 'tyke':4}
    注:
      字典的值为键的长度


字典 VS 列表
  1. 都是可变对象
  2. 索引方式不同,列表用整数索引，字典用键索引
  3. 字典的插入，删除，修改数据的速度可能会快于列表(重要)
  4. 列表的存储是有序的，字典的存储是无序的


练习:
  1. 已知有两个等长的列表 list1  和 list2
  以list1中的元素为键，以list2中的元素为值，生成相应的字典
  list1 = [1001, 1002, 1003, 1004]
  list2 = ['Tom', 'Jerry', 'Spike', 'Tyke']
  生成的字典为：
    {1001: 'Tom', 1002:'Jerry', .....}

  2. 输入任意个学生的姓名，年龄，成绩，每个学生的信息存入字典中，然后放入至列表中，每个学生的信息需要手动输入
  当输入姓名为空时结束输入:
    如:
      请输入姓名:  xiaozhang
      请输入年龄:  20
      请输入成绩:  100
      请输入姓名:  xiaoli
      请输入年龄:  18
      请输入成绩:  98
      请输入姓名:  <回车> 结束输入
    要求内部存储格式如下:
    [{'name':'xiaozhang', 'age':20, 'score':100}, 
     {'name':'xiaoli', 'age':18, 'score':98}]
    打印所有学生的信息如下:
    +---------------+----------+----------+
    |     name      |   age    |   score  |
    +---------------+----------+----------+
    |   xiaozhang   |    20    |   100    |
    |     xiaoli    |    18    |    98    |
    +---------------+----------+----------+
